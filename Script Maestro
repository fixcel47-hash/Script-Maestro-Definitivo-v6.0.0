#!/usr/bin/env bash
# =================================================================================
# UNIFIED INSTALLER SCRIPT (v3.0.0 - Final)
# Ahora es un script UNIFICADO que contiene toda la lógica de instalación y ya no
# depende de la descarga del "installer.sh" desde una API.
# =================================================================================

SCRIPT_VERSION="3.0.0-FINAL"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# Configuracion de URLs para descarga de Stacks
# ¡Descarga directa desde GitHub!
# -----------------------------------------------
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)


declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# Lista de herramientas disponibles
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=()


# Función para mostrar mensajes
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Función para animación de espera
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Función para ejecutar comandos mostrando animación de espera
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    eval "$cmd" > /dev/null 2>&1 &
    local cmd_pid=$!
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    
    # Si el comando falla, registrar el error y salir
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló: $cmd"
        cleanup 1
        exit $exit_status
    fi
    
    return $exit_status
}

# Función de limpieza (incluye autodestrucción del script)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}  # Segundo parámetro opcional, por defecto false
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
        
        # Eliminar archivos temporales en caso de error
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    # Si se solicita, eliminar solo los archivos stack.yml (en caso de éxito)
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
        done
    fi
    
    # Autodestrucción del script unificado (setup.sh)
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        
        # Crear un script separado para la autodestrucción
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
# Esperar un momento para asegurar que el script principal ha terminado
sleep 1
# Intentar eliminar el script principal
rm -f "$SCRIPT_PATH"
# Comprobar si se eliminó correctamente
if [ -f "$SCRIPT_PATH" ]; then
  # Si no se pudo eliminar, intentar una vez más con sudo
  sudo rm -f "$SCRIPT_PATH"
fi
# Eliminar este script de autodestrucción
rm -f "\$0"
EOF

        # Hacer ejecutable el script de autodestrucción
        chmod +x "$self_destruct_script"
        
        # Ejecutar el script de autodestrucción en segundo plano
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    # Mostrar mensaje final de error/éxito
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM ERR

# Función para registrar un archivo temporal para limpieza posterior
register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
}


# Función para descargar archivos directamente desde el URL
download_stack_file() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "URL de descarga no encontrada para la herramienta: $tool_name"
        cleanup 1
        exit 1
    fi
    
    show_message "Descargando stack '$tool_name' desde GitHub..."
    
    # Usar curl para descargar de forma silenciosa, seguir redirecciones y guardar el archivo
    if ! curl -fsSL --max-time $DOWNLOAD_TIMEOUT -o "$local_path" "$download_url"; then
        show_error "Error al descargar el archivo stack para $tool_name desde $download_url"
        cleanup 1
        exit 1
    fi
    
    # Registrar el archivo como temporal
    register_temp_file "$local_path"
    show_success "Archivo stack para $tool_name descargado correctamente"
    return 0
}

# Función para generar clave aleatoria de 32 caracteres
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# Función para configurar tamaño de los logs de Docker
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"

    show_message "Configurando límites de logs en Docker..."

    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF

    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuración..."
}

# Función para configurar rkhunter
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"

    show_message "Configurando RKHunter..."

    run_command "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
                sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                "Aplicando configuración de RKHunter..."
}

# Verificar e instalar dependencias
install_dependencies() {
    show_message "Verificando e instalando dependencias..."
    
    apt-get update

    # Verificar si Docker está instalado
    if ! command -v docker &> /dev/null; then
        show_message "Instalando Docker..."
        apt-get install -y ca-certificates curl
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc
        echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker

        configure_docker_logs
    fi
    
    # Instalar otras herramientas necesarias
    apt-get install -y git curl wget
}

# Inicializar Docker Swarm si no está activo
initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        show_message "Iniciando Docker Swarm..."
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
        if [ $? -eq 0 ]; then
            show_success "Docker Swarm inicializado correctamente"
        else
            show_error "Error al inicializar Docker Swarm"
            cleanup 1
            exit 1
        fi
    else
        show_message "Docker Swarm ya está activo"
    fi

    INSTALLED_COMPONENTS["dependencies"]=true
}

# Instalar herramientas directamente en el servidor
install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    
    # Fail2Ban
    show_message "Instalando Fail2Ban..."
    apt-get install -y fail2ban
    systemctl enable fail2ban
    systemctl start fail2ban
    
    # RKHunter
    show_message "Instalando RKHunter..."
    echo "postfix postfix/main_mailer_type select No configuration" | debconf-set-selections
    apt-get install -y rkhunter
    configure_rkhunter
    rkhunter --update
    rkhunter --propupd
    
    # CHKRootkit
    show_message "Instalando CHKRootkit..."
    apt-get install -y chkrootkit

    # UFW
    show_message "Configurando UFW Firewall..."
    apt-get install -y ufw
    ufw allow ssh
    ufw allow http
    ufw allow https
    echo "y" | ufw enable
    
    show_success "Herramientas de seguridad instaladas correctamente"
    INSTALLED_COMPONENTS["security"]=true
}

# Crear redes de Docker para Swarm
create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
        show_success "Red 'frontend' creada"
    else
        show_warning "La red 'frontend' ya existe"
    fi
    
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
        show_success "Red 'backend' creada"
    else
        show_warning "La red 'backend' ya existe"
    fi
    
    INSTALLED_COMPONENTS["networks"]=true
}

# Función para crear directorios para volúmenes
create_volume_directories() {
    local stack_file=$1
    local tool_name=$2
    
    show_message "Creando directorios para volúmenes de $tool_name..."
    
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)

    if [ -z "$volume_paths" ]; then
        show_message "No se encontraron rutas de volúmenes para $tool_name"
        return
    fi

    for path in $volume_paths; do
        show_message "Creando directorio: $path"
        run_command "mkdir -p \"$path\"" "Creando directorio $path..."
        if [ $? -eq 0 ]; then
            show_success "Directorio $path creado correctamente"
        else
            show_error "Error al crear el directorio $path"
            cleanup 1
            exit 1
        fi
    done
}

# Función para inicializar la base de datos de Chatwoot
initialize_chatwoot_database() {
    local tool_name="chatwoot"
    local subdomain=$1
    
    show_message "Inicializando base de datos de Chatwoot..."
    
    show_message "Verificando disponibilidad de Redis..."
    local redis_ready=false
    local max_attempts=60
    local attempt=0
    
    container_id=$(docker ps --filter "name=redis-server" --format "{{.ID}}")
    
    while [ $attempt -lt $max_attempts ]; do
        if [ -z "$container_id" ]; then
            sleep 5
            container_id=$(docker ps --filter "name=redis-server" --format "{{.ID}}")
            attempt=$((attempt + 5))
            if [ $((attempt % 30)) -eq 0 ]; then
                show_message "Esperando contenedor Redis... ($attempt/$max_attempts segundos)"
            fi
            continue
        fi

        if docker exec -t "$container_id" redis-cli PING >/dev/null 2>&1; then
            redis_ready=true
            show_success "Redis está disponible"
            break
        fi

        sleep 5
        attempt=$((attempt + 5))
        if [ $((attempt % 30)) -eq 0 ]; then
            show_message "Esperando conexión a Redis... ($attempt/$max_attempts segundos)"
        fi
    done

    if [ "$redis_ready" = false ]; then
        show_error "No se pudo conectar a Redis. No se puede inicializar Chatwoot."
        cleanup 1
        exit 1
    fi
    
    show_message "Ejecutando setup inicial de Chatwoot..."

    local chatwoot_web_container=$(docker ps --filter "name=chatwoot-web" --format "{{.ID}}")
    
    if [ -z "$chatwoot_web_container" ]; then
        show_error "Contenedor 'chatwoot-web' no encontrado. Asegúrese de que el stack se haya desplegado correctamente."
        cleanup 1
        exit 1
    fi

    run_command "docker exec $chatwoot_web_container rails db:chatwoot_prepare" "Preparando base de datos..."
    run_command "docker exec $chatwoot_web_container rails assets:precompile" "Precompilando assets..."

    show_success "Base de datos y assets de Chatwoot inicializados correctamente"
}

# Función para sanitizar el archivo de stack
sanitize_stack_file() {
    local stack_file=$1
    local tool_name=$2
    local subdomain=$3
    
    show_message "Sanitizando archivo $tool_name-stack.yml..."

    # Reemplazar variables de entorno específicas
    run_command "sed -i 's|N8N_ENCRYPTION_KEY=.*|N8N_ENCRYPTION_KEY=$SECRET_KEY|g' \"$stack_file\"" "Aplicando SECRET_KEY..."
    run_command "sed -i 's|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Postgres..."
    run_command "sed -i 's|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Redis..."
    run_command "sed -i 's|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a n8n/evoapi DB..."
    run_command "sed -i 's|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Chatwoot..."
    run_command "sed -i 's|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Portainer..."
    
    # Reemplazar dominio base y subdominio
    local full_domain="$subdomain.$BASE_DOMAIN"
    
    # Reemplazar variables de dominio
    run_command "sed -i 's/Host(\`proxy\.midominio\.com\`)/Host(\`$full_domain\`)/g' \"$stack_file\"" "Aplicando dominio completo a Traefik..."
    run_command "sed -i 's/N8N_HOST=.*$/N8N_HOST=$full_domain/g' \"$stack_file\"" "Aplicando N8N_HOST..."
    run_command "sed -i 's|N8N_EDITOR_BASE_URL=.*|N8N_EDITOR_BASE_URL=https://$full_domain|g' \"$stack_file\"" "Aplicando N8N_EDITOR_BASE_URL..."
    run_command "sed -i 's/WEBHOOK_URL=https:\/\/webhook\..*$/WEBHOOK_URL=https:\/\/webhook.$full_domain/g' \"$stack_file\"" "Aplicando WEBHOOK_URL..."
    run_command "sed -i 's/HOST=.*$/HOST=$full_domain/g' \"$stack_file\"" "Aplicando HOST a EvoAPI..."
    run_command "sed -i 's/CHOOSETRAEFIKDOMAIN=.*$/CHOOSETRAEFIKDOMAIN=$full_domain/g' \"$stack_file\"" "Aplicando CHOOSETRAEFIKDOMAIN..."
    run_command "sed -i 's/HOST_NAME=.*$/HOST_NAME=$full_domain/g' \"$stack_file\"" "Aplicando HOST_NAME a Chatwoot..."
    run_command "sed -i 's/APP_DOMAIN=.*$/APP_DOMAIN=$full_domain/g' \"$stack_file\"" "Aplicando APP_DOMAIN a Chatwoot..."
    
    show_success "Archivo $tool_name-stack.yml sanitizado correctamente"
}

# Función para instalar una herramienta
install_docker_tool() {
    local tool_name=$1
    local default_subdomain=$2
    local tool_index=$3

    show_message "Iniciando instalación de $tool_name..."

    # 1. Solicitar subdominio
    local subdomain
    read -p "Ingrese el subdominio para $tool_name (predeterminado: $default_subdomain.$BASE_DOMAIN): " subdomain
    subdomain=${subdomain:-$default_subdomain}
    
    CUSTOM_SUBDOMAINS[$tool_index]=$subdomain
    local tool_dir="$DOCKER_DIR/$tool_name"
    mkdir -p "$tool_dir"
    echo "$subdomain" > "$tool_dir/.subdomain"

    # 2. Descargar el archivo de stack
    local stack_file="$tool_dir/$tool_name-stack.yml"
    
    download_stack_file "$tool_name" "$stack_file"
    
    # 3. Sanitizar el archivo
    sanitize_stack_file "$stack_file" "$tool_name" "$subdomain"

    # 4. Crear directorios de volúmenes
    create_volume_directories "$stack_file" "$tool_name"

    # 5. Desplegar el stack
    run_command "docker stack deploy -c \"$stack_file\" \"$tool_name\"" "Desplegando stack $tool_name..."

    # 6. Post-despliegue (solo para Chatwoot)
    if [ "$tool_name" == "chatwoot" ]; then
        initialize_chatwoot_database "$subdomain"
    fi

    show_success "Instalación de $tool_name completada."
}

# =========================================================================
# FLUJO PRINCIPAL DEL SCRIPT UNIFICADO
# =========================================================================

echo -e "\n${GREEN}===========================================${NC}"
echo -e "${GREEN}  🌸 Queen Novedad | Instalador Docker 🌸  ${NC}"
echo -e "${GREEN}===========================================${NC}\n"

# 1. Verificar si el script se ejecuta como root
if [ "$EUID" -ne 0 ]; then
    show_error "Este script debe ejecutarse como root"
    exit 1
fi

# 2. Configuración inicial (directorio y variables de usuario)
DOCKER_DIR="/home/docker"
mkdir -p $DOCKER_DIR
cd $DOCKER_DIR || { 
    show_error "No se pudo acceder al directorio $DOCKER_DIR"
    exit 1
}

show_message "Configuración inicial"
read -p "Ingrese la contraseña común para todas las herramientas: " COMMON_PASSWORD
if [ -z "$COMMON_PASSWORD" ]; then
    show_error "La contraseña no puede estar vacía"
    exit 1
fi

read -p "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
if [ -z "$BASE_DOMAIN" ]; then
    show_error "El dominio no puede estar vacío"
    exit 1
fi

DEFAULT_SECRET_KEY=$(generate_random_key)
read -p "Ingrese una clave secreta de 32 caracteres para las herramientas (o presione Enter para usar una clave generada automáticamente): " SECRET_KEY
SECRET_KEY=${SECRET_KEY:-$DEFAULT_SECRET_KEY}

if [ ${#SECRET_KEY} -ne 32 ]; then
    show_warning "La clave proporcionada no tiene 32 caracteres. Se utilizará una clave generada automáticamente."
    SECRET_KEY=$DEFAULT_SECRET_KEY
fi

show_message "Se utilizará la siguiente clave secreta: $SECRET_KEY"

# Guardar variables globales
env_global_file="$DOCKER_DIR/.env.global"
cat > $env_global_file << EOL
COMMON_PASSWORD=$COMMON_PASSWORD
BASE_DOMAIN=$BASE_DOMAIN
SECRET_KEY=$SECRET_KEY
EOL

# 3. Instalación de dependencias y servicios base
install_dependencies
initialize_docker_swarm
install_server_tools
create_docker_networks

# 4. Instalar herramientas Docker
show_message "Iniciando la instalación de las herramientas de Docker..."

for i in "${!SELECTED_TOOLS[@]}"; do
    tool_name="${SELECTED_TOOLS[$i]}"
    
    tool_index=-1
    for j in "${!AVAILABLE_TOOLS[@]}"; do
        if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
            tool_index=$j
            break
        fi
    done

    if [ $tool_index -ge 0 ]; then
        default_subdomain="${DEFAULT_SUBDOMAINS[$tool_index]}"
        install_docker_tool "$tool_name" "$default_subdomain" "$tool_index"
        
        if [ "$tool_name" = "postgres" ] || [ "$tool_name" = "redis" ]; then
            show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
            sleep 15
        fi
    fi
done

# 5. Mensaje final y URLs
show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
echo ""
echo "Accede a tus servicios en los siguientes URLs:"

# Mostrar URLs de los servicios instalados usando los subdominios personalizados
for i in "${!SELECTED_TOOLS[@]}"; do
    tool_name="${SELECTED_TOOLS[$i]}"

    tool_index=-1
    for j in "${!AVAILABLE_TOOLS[@]}"; do
        if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
            tool_index=$j
            break
        fi
    done

    if [ $tool_index -ge 0 ]; then
        # Leer el subdominio personalizado del archivo guardado
        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${CUSTOM_SUBDOMAINS[$tool_index]}"
            if [ -z "$subdomain" ]; then
                subdomain="${DEFAULT_SUBDOMAINS[$tool_index]}"
            fi
        fi

        echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN"
    fi
done

echo ""
echo "Información de credenciales:"
echo "- Contraseña común: $COMMON_PASSWORD"
echo "- Clave secreta: $SECRET_KEY"
echo ""
echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"

cleanup 0 true # Eliminar los stacks y el script en caso de éxito
