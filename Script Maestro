#!/usr/bin/env bash
# =================================================================================
# INSTALADOR DOCKER SWARM MAJORADO (v5.0.0 - SEGURIDAD Y ESTABILIDAD FINAL)
# Incluye: Fail2Ban, rkhunter y UFW.
# FIX: Redes, Redis, y Inicialización de Chatwoot DB (robusta y con limpieza).
# =================================================================================

SCRIPT_VERSION="5.0.0-FINAL-SEC-ROBUST-UFW"

# --- Colores para mensajes ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Variables de entorno ---
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

# --- URLs COMPLETAS y CORRECTAS (SUBSTITUYA POR SUS PRÓPRIAS URLS ESTABLES) ---
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")


# --- Funciones de Control y Error ---

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

run_command() {
    local cmd=$1; local msg=$2
    
    show_message "$msg"
    echo -e "${YELLOW}Ejecutando: ${cmd}${NC}"
    echo "--------------------------- INICIO OUTPUT ---------------------------"

    local output
    output=$(eval "$cmd" 2>&1)
    local exit_status=$?
    
    echo "$output"

    echo "--------------------------- FIN OUTPUT ----------------------------"
    
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló con estado $exit_status."
        show_error "Comando: ${cmd}"
        cleanup 1; exit $exit_status
    fi
    
    show_success "Comando completado exitosamente."
    return 0
}

# FUNCIÓN DE ESPERA ROBUSTA
wait_for_service() {
    local stack_name=$1
    local max_wait=180 
    local wait_time=0
    show_message "Verificando el estado de salud del stack '$stack_name'. Máximo de espera: $max_wait segundos."

    while [ $wait_time -lt $max_wait ]; do
        local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1)
        
        if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; then
            local running=$(echo "$status" | cut -d '/' -f 1)
            local desired=$(echo "$status" | cut -d '/' -f 2)
            
            if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ]; then
                show_success "Servicio '$stack_name' listo ($running/$desired réplicas)."
                return 0
            fi
        fi
        
        local failed_tasks=$(docker service ps "$stack_name" --filter "desired-state=running" --filter "state=failed" --format "{{.ID}}" 2>/dev/null)
        if [ -n "$failed_tasks" ]; then
            show_error "El servicio '$stack_name' tiene tareas fallidas. Revisando logs para diagnóstico..."
            docker service ps "$stack_name" --no-trunc
            if [ "$stack_name" == "redis" ]; then
                show_message "Extrayendo logs del servicio redis_redis-server fallido..."
                docker service logs "${stack_name}_redis-server" 2>/dev/null
            fi
            return 1
        fi
        
        sleep 10
        wait_time=$((wait_time + 10))
        show_message "Esperando réplicas estables de '$stack_name': Estado actual $status. (Tiempo: $wait_time/$max_wait)"
    done

    show_error "El servicio '$stack_name' no se estabilizó después de $max_wait segundos. Revise los logs."
    docker service ps "$stack_name" --no-trunc
    return 1
}


cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..."
        for tool_name in "${AVAILABLE_TOOLS[@]}"; do
             docker stack rm "$tool_name" 2>/dev/null
        done
        docker stack rm chatwoot-init 2>/dev/null
        sleep 5
        
        show_warning "Intentando remover volumen 'chatwoot_postgres' fallido."
        docker volume rm chatwoot_postgres 2>/dev/null
        
        show_error "Error detectado durante la instalación. Limpiando archivos temporales..."
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then rm -f "$file"; fi
            done
        fi
    fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        # Eliminar archivos de despliegue .yml en caso de fallo o finalización exitosa
        for tool_name in "${AVAILABLE_TOOLS[@]}"; do
            local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml"
            if [ -f "$deploy_file" ]; then rm -f "$deploy_file"; fi
        done
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configuración de trampas (traps) para asegurar la limpieza ante cualquier error/señal
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM ERR

register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); }

generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# Función de descarga
download_stack_content() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "ERROR: URL de descarga no definida para $tool_name."
        cleanup 1; exit 1
    fi
    
    show_message "Descargando stack de $tool_name desde: $download_url"

    if ! curl -fsSL --max-time $DOWNLOAD_TIMEOUT -o "$local_path" "$download_url"; then
        show_error "Fallo al descargar el archivo stack para $tool_name. Código de error: $?."
        cleanup 1; exit 1
    fi
    
    if [ ! -s "$local_path" ]; then
        show_error "El archivo descargado está vacío o no existe."
        rm -f "$local_path"
        cleanup 1; exit 1
    fi

    show_success "Archivo $tool_name-stack.yml descargado y verificado."
    register_temp_file "$local_path"
}


# --- Funciones de Instalación Base y Seguridad (UFW INTEGRADO) ---

# Función para instalar Fail2Ban, rkhunter y UFW
install_security_tools() {
    show_message "Instalando herramientas de seguridad (Fail2Ban, rkhunter y UFW)..."
    
    # Instalar todas las dependencias incluyendo 'ufw'
    run_command "apt update && apt install -y fail2ban rkhunter curl wget ufw" "Actualizando paquetes e instalando dependencias de seguridad y UFW..."
    
    show_success "Herramientas de seguridad instaladas."
}

# Función para configurar Fail2Ban, rkhunter y UFW
configure_security_tools() {
    show_message "Configurando rkhunter, Fail2Ban y UFW..."
    
    # 1. Configuración de rkhunter
    run_command "rkhunter --update" "Actualizando base de datos de rkhunter..."
    run_command "rkhunter --propcheck" "Comprobando propiedades de archivos (puede tomar tiempo)..."
    show_message "Para ejecutar un chequeo completo de rkhunter, use: rkhunter -c --rwo"
    
    # 2. Configuración de Fail2Ban
    run_command "cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local" "Creando archivo de configuración local de Fail2Ban..."
    run_command "systemctl enable fail2ban" "Habilitando servicio Fail2Ban..."
    run_command "systemctl start fail2ban" "Iniciando servicio Fail2Ban..."
    
    # 3. Configuración de UFW (Uncomplicated Firewall)
    show_message "Configurando y habilitando UFW Firewall..."
    # Permitir SSH, HTTP y HTTPS (80 y 443 para Traefik)
    run_command "ufw allow ssh" "Permitiendo acceso SSH (puerto 22)..."
    run_command "ufw allow http" "Permitiendo acceso HTTP (puerto 80)..."
    run_command "ufw allow https" "Permitiendo acceso HTTPS (puerto 443)..."
    
    # Habilitar UFW y confirmar
    if echo "y" | ufw enable; then
        show_success "UFW activado y configurado."
    else
        show_error "Fallo al activar UFW. Revise los logs."
        cleanup 1; exit 1
    fi

    show_success "Herramientas de seguridad configuradas y activas."
}


initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
    else
        show_message "Docker Swarm ya está activo"
    fi
}

create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    # FIX CRÍTICO: Usar una verificación robusta y crearlas si no existen.
    if ! docker network inspect frontend &>/dev/null; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
    else
        show_message "Red 'frontend' ya existe."
    fi
    if ! docker network inspect backend &>/dev/null; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
    else
        show_message "Red 'backend' ya existe."
    fi
}

pre_pull_images() {
    show_message "Pre-descargando imágenes críticas para evitar fallos de red/timeout..."
    local images=("redis:latest" "pgvector/pgvector:pg16" "chatwoot/chatwoot:latest" "traefik:v2.11" "portainer/portainer-ce:latest")
    for img in "${images[@]}"; do
        run_command "docker pull $img" "Descargando imagen $img..." || continue
    done
}


# --- Función CRÍTICA de Inicialización de Chatwoot DB (con FIX Avanzado) ---

initialize_chatwoot_database() {
    show_message "Iniciando base de datos de Chatwoot (Proceso avanzado con FIX)..."
    
    # FIX: Verificación de Redis (Verificación activa de dependencias)
    show_message "Verificando que el servicio Redis esté disponible..."
    local redis_service_name="redis_redis-server"
    local redis_container_id=""
    local redis_ready=false
    local max_wait_redis=120
    local wait_time_redis=0

    while [ $wait_time_redis -lt $max_wait_redis ] && [ "$redis_ready" = false ]; do
        # Busca el contenedor de redis_redis-server que esté corriendo
        redis_container_id=$(docker ps -q --filter "name=${redis_service_name}" 2>/dev/null | head -1)
        
        if [ -n "$redis_container_id" ]; then
            # Intenta ejecutar PING dentro del contenedor para verificar la salud
            if docker exec "$redis_container_id" redis-cli PING >/dev/null 2>&1; then
                redis_ready=true
                break
            fi
        fi
        sleep 5; wait_time_redis=$((wait_time_redis + 5))
        show_message "Esperando a que Redis esté listo... ($wait_time_redis/$max_wait_redis segundos)"
    done

    if [ "$redis_ready" = false ]; then
        show_error "Redis no está disponible. No se puede iniciar la inicialización de
