#!/usr/bin/env bash
# =================================================================================
# UNIFIED INSTALLER SCRIPT (v3.0.3 - FIX YAML/Chatwoot Syntax)
# =================================================================================

SCRIPT_VERSION="3.0.3-FIX"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# Configuracion de URLs para descarga de Stacks
# -----------------------------------------------
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)


declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# Lista de herramientas disponibles y subdominios predeterminados
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=()


# Funciones de utilidad para mensajes
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Función para animación de espera
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    # Este 'grep Usage' está viniendo de la subshell al ejecutar el comando.
    # Se reemplaza el mensaje de [COMPLETADO] para no ocultar la salida de grep en los logs
    # El grep Usage es benigno si el comando principal no falla.
    echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Función para ejecutar comandos mostrando animación de espera
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    # Ejecutar en subshell para capturar el PID y redirigir la salida
    # Redirigimos la salida del comando a un archivo temporal para verificar errores reales
    local temp_output_file=$(mktemp)
    
    # Ejecutamos el comando en segundo plano en una subshell
    (eval "$cmd" > "$temp_output_file" 2>&1) &
    local pid=$!
    
    # Mostrar la animación
    spinner $pid
    wait $pid
    local exit_status=$?

    # Si el comando falla, registrar el error y salir
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló: $cmd"
        show_error "Salida/Error del comando:"
        cat "$temp_output_file"
        rm -f "$temp_output_file"
        cleanup 1
        exit $exit_status
    fi
    
    rm -f "$temp_output_file"
    return $exit_status
}

# Función de limpieza (incluye autodestrucción del script)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado. Limpiando archivos temporales..."
        
        # Eliminar archivos temporales en caso de error
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    # Si se solicita, eliminar solo los archivos stack.yml (en caso de éxito)
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
        done
    fi
    
    # Autodestrucción del script
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF

        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    # Mostrar mensaje final de error/éxito
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM ERR

# Función para registrar un archivo temporal
register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
}


# Función para descargar archivos directamente desde el URL
download_stack_file() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "URL de descarga no encontrada para la herramienta: $tool_name"
        cleanup 1
        exit 1
    fi
    
    show_message "Descargando stack '$tool_name' desde GitHub..."
    
    if ! curl -fsSL --max-time $DOWNLOAD_TIMEOUT -o "$local_path" "$download_url"; then
        show_error "Error al descargar el archivo stack para $tool_name desde $download_url"
        cleanup 1
        exit 1
    fi
    
    register_temp_file "$local_path"
    show_success "Archivo stack para $tool_name descargado correctamente"
    return 0
}

# Función para generar clave aleatoria de 32 caracteres
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# Configuración de dependencias, Swarm y seguridad (omitido para brevedad, asumiendo que ya funciona)
# ...

# Función para crear directorios para volúmenes
create_volume_directories() {
    local stack_file=$1
    local tool_name=$2
    
    show_message "Creando directorios para volúmenes de $tool_name..."
    
    # FIX: Usar el separador '@' en lugar de '/' para evitar problemas con las rutas
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)

    if [ -z "$volume_paths" ]; then
        show_message "No se encontraron rutas de volúmenes para $tool_name"
        return
    fi

    for path in $volume_paths; do
        show_message "Creando directorio: $path"
        run_command "mkdir -p \"$path\"" "Creando directorio $path..."
    done
}

# Función para inicializar la base de datos de Chatwoot
initialize_chatwoot_database() {
    local tool_name="chatwoot"
    local subdomain=$1
    
    show_message "Inicializando base de datos de Chatwoot..."
    
    show_message "Verificando disponibilidad de Redis..."
    # Lógica de verificación de Redis omitida para brevedad, asumiendo que funciona
    
    # Se necesita el COMMON_PASSWORD para la conexión de Redis:
    COMMON_PASSWORD=$(grep '^COMMON_PASSWORD=' $DOCKER_DIR/.env.global | cut -d'=' -f2)
    
    local redis_ready=false
    local max_attempts=60
    local attempt=0
    
    container_id=""
    while [ $attempt -lt $max_attempts ]; do
        # Buscar el contenedor Redis del stack 'redis'
        container_id=$(docker ps --filter "name=redis_redis-server" --format "{{.ID}}")
        
        if [ ! -z "$container_id" ]; then
             # Usar la contraseña del $COMMON_PASSWORD inyectada en el comando
             if docker exec -t "$container_id" redis-cli -a "$COMMON_PASSWORD" PING >/dev/null 2>&1; then
                redis_ready=true
                show_success "Redis está disponible"
                break
            fi
        fi

        sleep 5
        attempt=$((attempt + 5))
        if [ $((attempt % 30)) -eq 0 ]; then
            show_message "Esperando contenedor/conexión Redis... ($attempt/$max_attempts segundos)"
        fi
    done

    if [ "$redis_ready" = false ]; then
        show_error "No se pudo conectar a Redis. No se puede inicializar Chatwoot."
        cleanup 1
        exit 1
    fi
    
    show_message "Ejecutando setup inicial de Chatwoot..."

    # Buscar el contenedor chatwoot_web (la única réplica)
    local chatwoot_web_container=$(docker ps --filter "name=${tool_name}_web.1" --format "{{.ID}}")
    
    if [ -z "$chatwoot_web_container" ]; then
        show_error "Contenedor 'chatwoot-web' no encontrado. Asegúrese de que el stack se haya desplegado correctamente."
        # Agregamos un comando para inspeccionar el estado del stack que falló:
        show_warning "Intentando mostrar el estado del stack 'chatwoot'..."
        docker stack services chatwoot
        cleanup 1
        exit 1
    fi

    # Ejecutar comandos de inicialización
    run_command "docker exec $chatwoot_web_container rails db:chatwoot_prepare" "Preparando base de datos..."
    run_command "docker exec $chatwoot_web_container rails assets:precompile" "Precompilando assets..."

    show_success "Base de datos y assets de Chatwoot inicializados correctamente"
}

# Función para sanitizar el archivo de stack
sanitize_stack_file() {
    local stack_file=$1
    local tool_name=$2
    local subdomain=$3
    
    show_message "Sanitizando archivo $tool_name-stack.yml..."

    # 1. Reemplazar variables de entorno específicas con la contraseña y clave secreta
    
    # FIX: Usar separador '@' en lugar de '/' para evitar conflictos con la clave secreta
    run_command "sed -i 's@N8N_ENCRYPTION_KEY=.*@N8N_ENCRYPTION_KEY=$SECRET_KEY@g' \"$stack_file\"" "Aplicando SECRET_KEY..."
    run_command "sed -i 's@POSTGRES_PASSWORD=.*@POSTGRES_PASSWORD=$COMMON_PASSWORD@g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Postgres..."
    run_command "sed -i 's@REDIS_PASSWORD=.*@REDIS_PASSWORD=$COMMON_PASSWORD@g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Redis (variable en Chatwoot/n8n)..."
    run_command "sed -i 's@DB_POSTGRESDB_PASSWORD=.*@DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD@g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a n8n/evoapi DB..."
    run_command "sed -i 's@RAILS_INBOUND_EMAIL_PASSWORD=.*@RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD@g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Chatwoot..."
    run_command "sed -i 's@PORTAINER_ADMIN_PASSWORD=.*@PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD@g' \"$stack_file\"" "Aplicando COMMON_PASSWORD a Portainer..."
    
    # 2. Reemplazar dominio base y subdominio
    local full_domain="$subdomain.$BASE_DOMAIN"
    
    # FIX ROBUSTO: Usar un delimitador no-barra-diagonal (como '@' o '#') para evitar que los puntos rompan el sed.
    # El patrón de sed es: s@pattern@replacement@g
    
    # Traefik (usa 'Host(`proxy.midominio.com`)')
    run_command "sed -i 's@Host(\`proxy\.midominio\.com\`)@Host(\`$full_domain\`)@g' \"$stack_file\"" "Aplicando dominio completo a Traefik..."
    
    # N8N (URL usa https://)
    run_command "sed -i 's@N8N_HOST=.*@N8N_HOST=$full_domain@g' \"$stack_file\"" "Aplicando N8N_HOST..."
    run_command "sed -i 's@N8N_EDITOR_BASE_URL=.*@N8N_EDITOR_BASE_URL=https://$full_domain@g' \"$stack_file\"" "Aplicando N8N_EDITOR_BASE_URL..."
    run_command "sed -i 's@WEBHOOK_URL=https:\/\/webhook\..*@WEBHOOK_URL=https:\/\/webhook.$BASE_DOMAIN@g' \"$stack_file\"" "Aplicando WEBHOOK_URL..."
    
    # EvoAPI
    run_command "sed -i 's@HOST=.*@HOST=$full_domain@g' \"$stack_file\"" "Aplicando HOST a EvoAPI..."
    
    # Chatwoot
    run_command "sed -i 's@CHOOSETRAEFIKDOMAIN=.*@CHOOSETRAEFIKDOMAIN=$full_domain@g' \"$stack_file\"" "Aplicando CHOOSETRAEFIKDOMAIN..."
    run_command "sed -i 's@HOST_NAME=.*@HOST_NAME=$full_domain@g' \"$stack_file\"" "Aplicando HOST_NAME a Chatwoot..."
    run_command "sed -i 's@APP_DOMAIN=.*@APP_DOMAIN=$full_domain@g' \"$stack_file\"" "Aplicando APP_DOMAIN a Chatwoot..."


    # 3. FIX ROBUSTO para Redis (Añadir autenticación)
    if [ "$tool_name" = "redis" ]; then
        
        # a. Inyectar la contraseña en el COMANDO del redis-server
        run_command "sed -i '/command: redis-server --loglevel warning/s/--loglevel warning/--requirepass $COMMON_PASSWORD --loglevel warning/g' \"$stack_file\"" \
            "Añadiendo autenticación (requirepass) a Redis Server Command..."
            
        # b. Inyectar las VARIABLES DE ENTORNO para RedisInsight (conexión y seguridad)
        run_command "sed -i '/image: redislabs\/redisinsight:latest/a\        environment:\n          - REDISINSIGHT_PASSWORD=$COMMON_PASSWORD\n          - REDIS_PASSWORD=$COMMON_PASSWORD' \"$stack_file\"" \
            "Inyectando environment variables para RedisInsight..."
    fi
    
    show_success "Archivo $tool_name-stack.yml sanitizado correctamente"
}

# ... (El resto de funciones principales: install_docker_tool, etc. se mantienen)
# ...

# Función para instalar una herramienta
install_docker_tool() {
    local tool_name=$1
    local default_subdomain=$2
    local tool_index=$3

    show_message "Iniciando instalación de $tool_name..."

    # 1. Solicitar subdominio
    local subdomain
    read -p "Ingrese el subdominio para $tool_name (predeterminado: $default_subdomain.$BASE_DOMAIN): " subdomain
    subdomain=${subdomain:-$default_subdomain}
    
    CUSTOM_SUBDOMAINS[$tool_index]=$subdomain
    local tool_dir="$DOCKER_DIR/$tool_name"
    mkdir -p "$tool_dir"
    echo "$subdomain" > "$tool_dir/.subdomain"

    # 2. Descargar el archivo de stack
    local stack_file="$tool_dir/$tool_name-stack.yml"
    download_stack_file "$tool_name" "$stack_file"
    
    # 3. Sanitizar el archivo
    sanitize_stack_file "$stack_file" "$tool_name" "$subdomain"

    # 4. Crear directorios de volúmenes
    create_volume_directories "$stack_file" "$tool_name"

    # 5. Desplegar el stack
    run_command "docker stack deploy -c \"$stack_file\" \"$tool_name\"" "Desplegando stack $tool_name..."

    # 6. Post-despliegue (solo para Chatwoot)
    if [ "$tool_name" == "chatwoot" ]; then
        # La contraseña ya se lee en initialize_chatwoot_database
        initialize_chatwoot_database "$subdomain"
    fi

    show_success "Instalación de $tool_name completada."
}

# ... (El flujo principal se mantiene)
# ...

# =========================================================================
# FLUJO PRINCIPAL (Solo se incluye el final para ver que no cambia)
# =========================================================================
# ...

# 4. Instalar herramientas Docker (Aquí se ejecutaría la instalación)
# ...

# 5. Mensaje final y URLs
show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
# ...

cleanup 0 true
