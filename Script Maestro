#!/usr/bin/env bash
# =================================================================================
# INSTALADOR UNIFICADO DOCKER SWARM (v5.2.0 - MAESTRO FINAL CLONADO Y CORREGIDO)
# Autor: Adaptado y corregido por Gemini AI (integración Khunter Fix)
# Objetivo: Instalación robusta de stack Docker Swarm usando URLs directas de GitHub.
# =================================================================================

SCRIPT_VERSION="5.2.0-FINAL"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# 1. Configuración de Herramientas y URLs
# -----------------------------------------------
# Lista de herramientas disponibles
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
# Subdominios predeterminados
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "db" "n8" "api" "chat")

# 🚨 IMPORTANTE: Se usan las URLs temporales de 'user-attachments' proporcionadas.
# El script fallará si estas URLs caducan o si el contenido del YAML de inicialización
# de Chatwoot no se corrige con las variables seguras (ver Sección 2).
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [chatwoot-init]="https://github.com/user-attachments/files/22988366/chatwoot-init-stack.yml" 
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

# -----------------------------------------------
# 2. Funciones de Utilidad
# -----------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[ADVERTENCIA]${NC} $1"; }

read_input() {
    local prompt="$1"
    local default_val="$2"
    local result_var="$3"
    
    if [ -z "${!result_var}" ]; then
        echo -n -e "${BLUE}[PREGUNTA]${NC} $prompt (Predeterminado: $default_val): "
        read user_input
        if [ -z "$user_input" ]; then
            eval $result_var=\"$default_val\"
        else
            eval $result_var=\"$user_input\"
        fi
    fi
}

cleanup() {
    local exit_code=$1
    echo ""
    show_message "Realizando limpieza antes de salir..."
    
    if [ ${#TEMP_FILES[@]} -gt 0 ]; then
        rm -f "${TEMP_FILES[@]}" 2>/dev/null
    fi

    if [ $exit_code -ne 0 ] && [ -f "$DOCKER_DIR/.env.global" ]; then
        show_warning "El archivo $DOCKER_DIR/.env.global se mantiene para depuración. Elimínalo si es necesario."
    fi

    show_message "Limpieza de archivos temporales completada."
    
    if [ $exit_code -ne 0 ]; then
        show_error "Instalación fallida"
    else
        show_success "Instalación completada exitosamente"
    fi

    exit $exit_code
}

trap 'cleanup 1' ERR INT TERM

# -----------------------------------------------
# 3. Funciones de Pre-instalación y Variables
# -----------------------------------------------

validate_prerequisites() {
    if ! command -v docker &> /dev/null; then
        show_error "Docker no está instalado. Por favor, instala Docker y Docker Compose."
        cleanup 1
    fi

    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        show_message "Docker Swarm no está activo. Inicializando..."
        if ! docker swarm init &> /dev/null; then
            show_error "No se pudo inicializar Docker Swarm."
            cleanup 1
        fi
        show_success "Docker Swarm inicializado."
    fi
    show_success "Requisitos de Docker validados."
}

configure_variables() {
    show_message "Configuración de variables de entorno y credenciales."
    
    read_input "Ingrese el dominio base (ej. midominio.com)" "" BASE_DOMAIN
    # Generación de contraseñas/secrets aleatorios y seguros por defecto
    read_input "Ingrese la contraseña común para todos los servicios" "$(openssl rand -base64 12 | tr -d '=+/' | cut -c1-12)" COMMON_PASSWORD
    read_input "Ingrese la clave secreta única" "$(openssl rand -base64 24 | tr -d '=+/' | cut -c1-24)" SECRET_KEY

    export BASE_DOMAIN COMMON_PASSWORD SECRET_KEY DOCKER_DIR

    mkdir -p "$DOCKER_DIR"
    {
        echo "BASE_DOMAIN=$BASE_DOMAIN"
        echo "COMMON_PASSWORD=$COMMON_PASSWORD"
        echo "SECRET_KEY=$SECRET_KEY"
    } > "$DOCKER_DIR/.env.global"
    show_success "Variables globales guardadas en $DOCKER_DIR/.env.global"
    
    show_message "Seleccione las herramientas a instalar (separadas por espacio):"
    echo "Opciones disponibles: ${AVAILABLE_TOOLS[@]}"
    
    read -p "Su selección (ej. traefik portainer chatwoot): " USER_SELECTION
    
    local -a selected_temp
    for tool in $USER_SELECTION; do
        if [[ " ${AVAILABLE_TOOLS[@]} " =~ " ${tool} " ]]; then
            selected_temp+=("$tool")
        else
            show_warning "Herramienta '$tool' no reconocida y será ignorada."
        fi
    done

    # Corrección para el error 'No se seleccionó ninguna herramienta válida.'
    if [ ${#selected_temp[@]} -eq 0 ]; then
        show_error "No se seleccionó ninguna herramienta válida. Abortando. Asegúrate de incluir 'traefik' en la lista."
        cleanup 1
    fi
    
    SELECTED_TOOLS=("${selected_temp[@]}")
    show_message "Herramientas seleccionadas: ${SELECTED_TOOLS[@]}"

    declare -gA CUSTOM_SUBDOMAINS
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        
        # Obtener el subdominio predeterminado correcto
        local default_subdomain_found=""
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
                default_subdomain_found="${DEFAULT_SUBDOMAINS[$j]}"
                break
            fi
        done
        
        read_input "Ingrese el subdominio para $tool_name" "$default_subdomain_found" "CUSTOM_SUBDOMAINS[$tool_name]"
        
        echo "${CUSTOM_SUBDOMAINS[$tool_name]}" > "$DOCKER_DIR/$tool_name/.subdomain"
        export ${tool_name^^}_SUBDOMAIN="${CUSTOM_SUBDOMAINS[$tool_name]}"
    done
}

create_networks_and_dirs() {
    show_message "Creando directorios y redes Docker Swarm..."
    
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        mkdir -p "$DOCKER_DIR/$tool_name"
    done
    
    for network in "traefik-public" "docker-flow"; do
        if ! docker network ls | grep -q "$network"; then
            show_message "Creando red '$network'..."
            docker network create -d overlay --attachable "$network" >/dev/null
            if [ $? -ne 0 ]; then
                show_error "No se pudo crear la red $network."
                cleanup 1
            fi
        fi
    done
    show_success "Directorios y redes creados."
}

# -----------------------------------------------
# 4. Funciones de Instalación Críticas (Khunter Fix)
# -----------------------------------------------

# FUNCIÓN CORREGIDA: Inicialización robusta de Chatwoot (Khunter Fix)
initialize_chatwoot_database() {
    local final_stack_name="chatwoot"
    local init_stack_name="chatwoot-init"
    # El volumen que crea el stack de inicialización
    local postgres_volume_name="${init_stack_name}_chatwoot-postgres-data"
    
    show_message "Iniciando proceso de inicialización de Chatwoot (Stack Temporal: $init_stack_name)..."
    
    # 1. Descargar y desplegar el stack TEMPORAL de inicialización
    local temp_file="$DOCKER_DIR/$final_stack_name/${init_stack_name}.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot-init]}" -o "$temp_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el stack de inicialización de Chatwoot. Abortando. URL: ${STACK_URLS[chatwoot-init]}"
        return 1
    fi
    TEMP_FILES+=("$temp_file")
    
    show_message "Desplegando stack temporal '$init_stack_name' para la base de datos. ¡Debe tener el YAML corregido!"
    # Se usa --env-file para inyectar credenciales de forma segura
    docker stack deploy -c "$temp_file" --env-file "$DOCKER_DIR/.env.global" "$init_stack_name"
    
    show_message "Esperando 45 segundos a que la base de datos de inicialización esté lista..."
    sleep 45

    # 2. Ejecutar la migración
    # Buscamos el servicio de inicialización, que puede llamarse 'chatwoot-setup' (ideal) o 'db-init' (archivo original).
    local init_container_id=$(docker service ps -q "${init_stack_name}_chatwoot-setup" --filter "desired-state=running" | head -n 1)
    
    if [ -z "$init_container_id" ]; then
        show_warning "No se encontró el contenedor 'chatwoot-setup'. Probando con 'db-init' (archivo original del usuario)..."
        init_container_id=$(docker service ps -q "${init_stack_name}_db-init" --filter "desired-state=running" | head -n 1)
        if [ -z "$init_container_id" ]; then
             show_error "Contenedor de setup no encontrado. Abortando inicialización."
             return 1
        fi
    fi
    
    show_message "Ejecutando la inicialización (db:setup) dentro del contenedor $init_container_id..."
    
    # El comando forzado a 'rails db:setup' es la corrección de estabilidad.
    if ! docker container exec -t "$init_container_id" /bin/bash -c "RAILS_ENV=production bundle exec rails db:setup"; then
        show_warning "El comando db:setup finalizó con un código de error. Continuando con la limpieza..."
    fi

    # 3. Limpiar el stack TEMPORAL
    show_message "Eliminando el stack temporal '$init_stack_name'..."
    docker stack rm "$init_stack_name"
    show_success "Stack temporal '$init_stack_name' eliminado."

    # 4. CORRECCIÓN KHUNTER: Eliminar el volumen de datos de la inicialización de forma robusta
    show_message "Intentando eliminar el volumen temporal '$postgres_volume_name'..."
    local attempts=0
    local max_attempts=5
    local success=0

    while [ $attempts -lt $max_attempts ]; do
        if docker volume rm "$postgres_volume_name" 2>/dev/null; then
            show_success "Volumen temporal '$postgres_volume_name' eliminado."
            success=1
            break
        else
            show_message "Intento $((attempts+1)): Volumen aún en uso. Esperando 5 segundos..."
            sleep 5
            attempts=$((attempts+1))
        fi
    done

    if [ $success -eq 0 ]; then
        show_warning "No se pudo eliminar el volumen '$postgres_volume_name'. Podría requerir eliminación manual."
    fi

    show_success "Base de datos de Chatwoot inicializada."

    # 5. Desplegar el stack FINAL de Chatwoot
    local final_deploy_file="$DOCKER_DIR/$final_stack_name/${final_stack_name}-deploy.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot]}" -o "$final_deploy_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el stack final de Chatwoot. Abortando."
        return 1
    fi
    TEMP_FILES+=("$final_deploy_file")
    
    show_message "Desplegando chatwoot (Stack Final: $final_stack_name)..."
    docker stack deploy -c "$final_deploy_file" --env-file "$DOCKER_DIR/.env.global" "$final_stack_name"
    
    return 0
}

# Función para el resto de stacks
deploy_stack() {
    local tool_name="$1"

    show_message "Iniciando instalación de $tool_name..."
    
    # 1. Descargar Stack File
    local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[$tool_name]}" -o "$stack_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el archivo stack para $tool_name. Revisar URL: ${STACK_URLS[$tool_name]}"
        return 1
    fi
    TEMP_FILES+=("$stack_file")

    # 2. Despliegue del Stack
    docker stack deploy -c "$stack_file" --env-file "$DOCKER_DIR/.env.global" "$tool_name"
    
    if [ $? -ne 0 ]; then
        show_error "Error al desplegar el stack $tool_name."
        return 1
    fi
    show_success "Stack $tool_name desplegado."
    
    # 3. Post-instalación (esperas para estabilidad)
    if [ "$tool_name" == "redis" ] || [ "$tool_name" == "postgres" ]; then
        show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
        sleep 15
    fi

    return 0
}

# -----------------------------------------------
# 5. Flujo Principal
# -----------------------------------------------

main_installation() {
    validate_prerequisites
    configure_variables
    create_networks_and_dirs

    # Desplegar Traefik (debe ser el primero)
    if [[ " ${SELECTED_TOOLS[@]} " =~ " traefik " ]]; then
        deploy_stack "traefik" || cleanup 1
        
        show_message "Esperando 30 segundos para el provisionamiento inicial de Traefik y Let's Encrypt..."
        sleep 30 
    else
        show_error "El stack Traefik es obligatorio. Por favor, inclúyelo en la selección."
        cleanup 1
    fi

    # Desplegar el resto de herramientas
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        if [ "$tool_name" == "traefik" ]; then
            continue
        fi

        if [ "$tool_name" == "chatwoot" ]; then
            # Flujo de inicialización de Chatwoot
            initialize_chatwoot_database || cleanup 1
        else
            # Flujo de despliegue estándar
            deploy_stack "$tool_name" || cleanup 1
        fi
    done

    # 6. Mensaje final y limpieza
    finalize_installation
}

finalize_installation() {
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    show_message "Verifique que todos los servicios estén en estado '1/1' con 'docker service ls'."
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${CUSTOM_SUBDOMAINS[$tool_name]}"
        fi

        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"
    
    cleanup 0
}

# Ejecutar el script
main_installation
