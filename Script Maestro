#!/bin/bash

# ==============================================================================
# Script de Instalación de Herramientas de Seguridad
# Clonado directamente de la lógica de installer.sh
# ==============================================================================

# --- Colores para mensajes (idénticos al script original) ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Funciones para mostrar mensajes (idénticas al script original) ---
show_message() {
    [cite_start]echo -e "${BLUE}[INFO]${NC} $1" [cite: 1]
}

show_error() {
    [cite_start]echo -e "${RED}[ERROR]${NC} $1" [cite: 1]
}

show_success() {
    [cite_start]echo -e "${GREEN}[SUCCESS]${NC} $1" [cite: 1]
}

# --- Función para animación de espera (idéntica al script original) ---
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    echo -n "Procesando 
[cite_start]" [cite: 2]
    [cite_start]while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; [cite: 2, 3]
do
        [cite_start]local temp=${spinstr#?} [cite: 3]
        [cite_start]printf " [%c]  " "$spinstr" [cite: 3]
        [cite_start]local spinstr=$temp${spinstr%"$temp"} [cite: 3]
        [cite_start]sleep $delay [cite: 3]
        [cite_start]printf "\b\b\b\b\b\b" [cite: 3]
    done
    [cite_start]printf "    \b\b\b\b" [cite: 3]
    [cite_start]echo -e "${GREEN}[COMPLETADO]${NC}" [cite: 3]
}

# --- Función para ejecutar comandos (idéntica al script original) ---
run_command_maestro() {
    local cmd=$1
    local msg=$2
    
    [cite_start]show_message "$msg" [cite: 4]
  
    [cite_start]eval "$cmd" > /dev/null 2>&1 & [cite: 4]
    [cite_start]local cmd_pid=$! [cite: 4]
    [cite_start]spinner $cmd_pid [cite: 5]
    [cite_start]wait $cmd_pid [cite: 5]
    [cite_start]local exit_status=$? [cite: 5]
    
    if [ $exit_status -ne 0 ];
[cite_start]then [cite: 6]
        [cite_start]show_error "Comando falló: $cmd" [cite: 6]
        [cite_start]exit $exit_status [cite: 6]
    fi
    
    [cite_start]return $exit_status [cite: 6]
}

# --- Función para configurar rkhunter (idéntica al script original) ---
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"

    show_message "Configurando RKHunter..."

    run_command_maestro "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
              
    sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                [cite_start]"Aplicando configuración de RKHunter..." [cite: 7]
}

# --- Función de instalación de herramientas (idéntica al script original) ---
install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    
    # Fail2Ban
    show_message "Instalando Fail2Ban..."
    apt-get install -y fail2ban
    systemctl enable fail2ban
    systemctl start fail2ban
    
    # RKHunter
    show_message "Instalando RKHunter..."
   
    [cite_start]echo "postfix postfix/main_mailer_type select No configuration" | debconf-set-selections [cite: 8]
    [cite_start]apt-get install -y rkhunter [cite: 8]
    [cite_start]configure_rkhunter  # Llama a la función de configuración después de instalar [cite: 8]
    [cite_start]rkhunter --update [cite: 8]
    [cite_start]rkhunter --propupd [cite: 8]
    
    # CHKRootkit
    show_message "Instalando CHKRootkit..."
    [cite_start]apt-get install -y chkrootkit [cite: 8]
    
    # UFW
    show_message "Configurando UFW Firewall..."
    [cite_start]apt-get install -y ufw [cite: 8]
    [cite_start]ufw allow ssh [cite: 8]
    [cite_start]ufw allow http [cite: 8]
   
    [cite_start]ufw allow https [cite: 9]
    [cite_start]echo "y" | [cite: 9, 10]
[cite_start]ufw enable [cite: 10]
    
    [cite_start]show_success "Herramientas de seguridad instaladas correctamente" [cite: 10]
}

# --- Función principal para ejecutar el proceso ---
main_maestro() {
    # Verificar si el script se ejecuta como root
    if [ "$EUID" -ne 0 ];
[cite_start]then [cite: 11]
        [cite_start]show_error "Este script debe ejecutarse como root" [cite: 11]
        [cite_start]exit 1 [cite: 11]
    fi
    
    # Actualizar repositorios antes de instalar
    [cite_start]show_message "Actualizando repositorios del sistema..." [cite: 11]
    [cite_start]apt-get update -y [cite: 11]
    
    # Llamar a la función principal de instalación de herramientas
    [cite_start]install_server_tools [cite: 11]
    
    [cite_start]echo "" [cite: 11]
    [cite_start]show_success "Proceso completado." [cite: 12]
}

# Ejecutar la función principal
main_maestro

# -------------------------------------------------------------------------------
# SEPARADOR ENTRE SCRIPTS
# -------------------------------------------------------------------------------


#!/usr/bin/env bash

# =================================================================================
# INSTALADOR DOCKER SWARM STANDALONE (V5.2 - MUESTRA TODO / CERO SPINNERS)
# Adaptado de installer_v4.9.sh y installer.sh, sin API y con output detallado.
# =================================================================================

[cite_start]SCRIPT_VERSION="5.2.0-STANDALONE-SUPER-VERBOSE" [cite: 14]

# [cite_start]Colores para mensajes [cite: 14]
[cite_start]RED='\033[0;31m' [cite: 14]
[cite_start]GREEN='\033[0;32m' [cite: 14]
[cite_start]YELLOW='\033[0;33m' [cite: 14]
[cite_start]BLUE='\033[0;34m' [cite: 14]
[cite_start]NC='\033[0m' # No Color [cite: 14]

# [cite_start]Variables de entorno [cite: 14]
[cite_start]DOCKER_DIR="/home/docker" [cite: 14]
[cite_start]SCRIPT_PATH=$(readlink -f "$0") [cite: 14]
[cite_start]TEMP_FILES=() [cite: 14]
[cite_start]DOWNLOAD_TIMEOUT=30 [cite: 14]

# [cite_start]URLs de stacks (ejemplos) [cite: 14]
declare -gA STACK_URLS=(
    [cite_start][chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml" [cite: 14]
    [cite_start][evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml" [cite: 14]
    [cite_start][n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml" [cite: 14]
    [cite_start][portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml" [cite: 14]
    [cite_start][postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml" [cite: 14]
    [cite_start][redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml" [cite: 14]
    [cite_start][traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml" [cite: 14]
)

[cite_start]AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot") [cite: 14]
[cite_start]DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat") [cite: 14]
[cite_start]SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot") [cite: 14]
[cite_start]CUSTOM_SUBDOMAINS=() [cite: 14]

[cite_start]COMMON_PASSWORD="" [cite: 14]
[cite_start]BASE_DOMAIN="" [cite: 14]
[cite_start]SECRET_KEY="" [cite: 14]

declare -gA INSTALLED_COMPONENTS=(
    [cite_start][dependencies]=false [cite: 14]
    [cite_start][security]=false [cite: 14]
    [cite_start][networks]=false [cite: 14]
)

# ----------------------------------------------------
# Funciones de Control y Ejecución
# ----------------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1";
[cite_start]} [cite: 15]
show_error() { echo -e "${RED}[ERROR]${NC} $1"; [cite_start]} [cite: 15]
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; [cite_start]} [cite: 15]
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1";
[cite_start]} [cite: 16]
register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); [cite_start]} [cite: 16]
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32;
[cite_start]} [cite: 17]

# Función de limpieza (ROBUSTA V4.9 + Autodestrucción)
cleanup() {
    [cite_start]local exit_code=$1 [cite: 17]
    [cite_start]local delete_stacks=${2:-false} [cite: 17]
    
    [cite_start]echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..." [cite: 17]
    
    if [ $exit_code -ne 0 ];
[cite_start]then [cite: 18]
        [cite_start]show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..." [cite: 18]
        
        # Eliminar stacks y volumen de inicialización de Chatwoot
        for tool_name in "${SELECTED_TOOLS[@]}";
[cite_start]do docker stack rm "$tool_name" 2>/dev/null; done [cite: 19]
        [cite_start]docker stack rm chatwoot-init 2>/dev/null [cite: 19]
        [cite_start]sleep 5 [cite: 19]
        
        # Intentar remover el volumen temporal de Chatwoot en caso de fallo (FIX V4.9)
        [cite_start]docker volume rm chatwoot_postgres 2>/dev/null [cite: 19]
        
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
      
    [cite_start]if [ ${#TEMP_FILES[@]} -gt 0 ]; then [cite: 20]
            for file in "${TEMP_FILES[@]}";
[cite_start]do if [ -f "$file" ]; then rm -f "$file"; fi; [cite: 21, 22]
[cite_start]done [cite: 22]
        fi
    fi
    
    # Si se solicita (en éxito), eliminar archivos de despliegue y autodestrucción
    if [ $exit_code -ne 0 ] ||
[cite_start][ "$delete_stacks" = true ]; then [cite: 23]
        for tool_name in "${SELECTED_TOOLS[@]}";
[cite_start]do [cite: 24]
            [cite_start]local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml" [cite: 24]
            if [ -f "$deploy_file" ];
[cite_start]then rm -f "$deploy_file"; fi [cite: 25]
        done
        
        # Lógica de autodestrucción
        [cite_start]local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh" [cite: 25]
        [cite_start]cat > "$self_destruct_script" << EOF_SD [cite: 25]
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ];
[cite_start]then sudo rm -f "$SCRIPT_PATH"; fi [cite: 26]
rm -f "\$0"
EOF_SD
        [cite_start]chmod +x "$self_destruct_script" [cite: 26]
        [cite_start]nohup "$self_destruct_script" >/dev/null 2>&1 & [cite: 26]
    fi
    
    [cite_start]echo -e "${BLUE}[INFO]${NC} Limpieza completada" [cite: 26]
    
    if [ $exit_code -ne 0 ];
[cite_start]then [cite: 27]
        [cite_start]echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información." [cite: 27]
else
        [cite_start]echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente" [cite: 28]
    fi
    
    [cite_start]exit $exit_code [cite: 28]
}

# Configurar trampas para señales para limpiar antes de salir
[cite_start]trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM [cite: 28]
[cite_start]trap 'cleanup 1 false' ERR [cite: 28]

# FUNCIÓN run_command (Modificada para Verbose): Ejecuta comandos mostrando TODO el output
run_command() {
    [cite_start]local cmd=$1 [cite: 28]
    [cite_start]local msg=$2 [cite: 28]
    
    [cite_start]show_message "$msg" [cite: 29]
    [cite_start]echo -e "${YELLOW}Ejecutando: ${cmd}${NC}" [cite: 29]
    [cite_start]echo "--------------------------- INICIO OUTPUT ---------------------------" [cite: 29]

    # Ejecuta el comando directamente (sin subshell ni archivos temporales) 
    [cite_start]if ! eval "$cmd"; [cite: 30]
then
        [cite_start]local exit_status=$? [cite: 30]
[cite_start]echo "--------------------------- FIN OUTPUT ----------------------------" [cite: 31]
        [cite_start]show_error "Comando falló con estado $exit_status." [cite: 32]
[cite_start]show_error "Comando: ${cmd}" [cite: 32]
        [cite_start]cleanup 1 # Llama a cleanup y sale con el estado de error [cite: 32]
    fi
    
    [cite_start]echo "--------------------------- FIN OUTPUT ----------------------------" [cite: 32]
    [cite_start]show_success "Comando completado exitosamente." [cite: 33]
[cite_start]return 0 [cite: 33]
}


# Función de descarga (CURL DIRECTO - Muestra la barra de progreso)
download_stack_content() {
    [cite_start]local tool_name=$1 [cite: 33]
    [cite_start]local local_path=$2 [cite: 33]
    [cite_start]local download_url=${STACK_URLS[$tool_name]} [cite: 33]

    if [ -z "$download_url" ];
[cite_start]then [cite: 34]
        [cite_start]show_error "ERROR: URL de descarga no definida para $tool_name." [cite: 34]
[cite_start]cleanup 1 [cite: 35]
    fi
    
    [cite_start]show_message "Descargando stack de $tool_name desde: $download_url" [cite: 35]

    # curl --progress-bar garantiza que se vea el progreso
    [cite_start]run_command "curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o \"$local_path\" \"$download_url\"" "Descargando archivo stack para $tool_name..." [cite: 35]
    
    if [ !
[cite_start]-s "$local_path" ]; then [cite: 36]
        [cite_start]show_error "El archivo descargado está vacío. URL incorrecta o inaccesible." [cite: 37]
[cite_start]rm -f "$local_path" [cite: 37]
        [cite_start]cleanup 1 [cite: 37]
    fi

    [cite_start]show_success "Archivo $tool_name-stack.yml descargado y verificado." [cite: 38]
[cite_start]register_temp_file "$local_path" [cite: 38]
}


# ----------------------------------------------------
# Funciones de Infraestructura y Despliegue (Robustez V4.9)
# ----------------------------------------------------

# MODIFICADA: Ahora muestra el estado del servicio cada 10s (CERO SPINNER)
wait_for_service() {
    [cite_start]local stack_name=$1 [cite: 38]
    [cite_start]local max_wait=180 [cite: 39]
    [cite_start]local wait_time=0 [cite: 39]
    [cite_start]show_message "Verificando el estado de salud del stack '$stack_name'. Máximo de espera: $max_wait segundos." [cite: 39]
[cite_start]while [ $wait_time -lt $max_wait ]; do [cite: 39]
        
        [cite_start]echo -e "${YELLOW}--- Estatus de Servicio ($stack_name) - Tareas y Réplicas: $wait_time/$max_wait segundos ---${NC}" [cite: 39]
        # Muestra el estado detallado de las tareas del servicio
        [cite_start]docker service ps "$stack_name" [cite: 39]
        [cite_start]echo -e "${YELLOW}-----------------------------------------------------------------------------------${NC}" [cite: 39]

        [cite_start]local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1) [cite: 39]
        
        
        [cite_start]if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; [cite: 41]
then
            [cite_start]local running=$(echo "$status" | cut -d '/' -f 1) [cite: 41]
            [cite_start]local desired=$(echo "$status" | cut -d '/' -f 2) [cite: 41]
            
            if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ];
[cite_start]then [cite: 42]
                [cite_start]show_success "Servicio '$stack_name' listo ($running/$desired réplicas)." [cite: 42]
[cite_start]return 0 [cite: 43]
            fi
        fi
        
        [cite_start]local failed_tasks=$(docker service ps "$stack_name" --filter "desired-state=running" --filter "state=failed" --format "{{.ID}}" 2>/dev/null) [cite: 43]
        if [ -n "$failed_tasks" ];
[cite_start]then [cite: 44]
            [cite_start]show_error "El servicio '$stack_name' tiene tareas fallidas. Revisando logs para diagnóstico..." [cite: 44]
            [cite_start]docker service ps "$stack_name" --no-trunc [cite: 44]
            if [ "$stack_name" == "redis" ];
[cite_start]then [cite: 45]
                [cite_start]show_message "Extrayendo logs del servicio redis_redis-server fallido..." [cite: 45]
                [cite_start]docker service logs "${stack_name}_redis-server" 2>/dev/null [cite: 45]
            fi
            [cite_start]return 1 [cite: 45]
        fi
        
        [cite_start]sleep 10 [cite: 45]
        
[cite_start]wait_time=$((wait_time + 10)) [cite: 46]
    done

    [cite_start]show_error "El servicio '$stack_name' no se estabilizó después de $max_wait segundos. Revise los logs." [cite: 46]
[cite_start]docker service ps "$stack_name" --no-trunc [cite: 47]
    [cite_start]return 1 [cite: 47]
}

# ----------------------------------------------------
# Funciones de Flujo (Utilizan el nuevo run_command)
# ----------------------------------------------------

install_dependencies() {
    [cite_start]show_message "Verificando e instalando dependencias..." [cite: 47]
    [cite_start]run_command "apt-get update" "Actualizando repositorios..." [cite: 47]
    [cite_start]run_command "apt-get install -y ca-certificates curl git wget" "Instalando utilidades (git, curl, wget)..." [cite: 47]
    if !
[cite_start]command -v docker &> /dev/null; then [cite: 48]
        [cite_start]show_message "Instalando Docker..." [cite: 48]
        [cite_start]run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..." [cite: 48]
        [cite_start]run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null" "Añadiendo repositorio de Docker..." [cite: 48]
        [cite_start]run_command "apt-get update" "Actualizando repositorios nuevamente..." [cite: 48]
        run_command "apt-get install -y docker-ce docker-ce-cli 
[cite_start]containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..." [cite: 49]
        [cite_start]run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..." [cite: 49]
    fi
    [cite_start]INSTALLED_COMPONENTS["dependencies"]=true [cite: 49]
}

initialize_docker_swarm() {
    [cite_start]show_message "Verificando estado de Docker Swarm..." [cite: 49]
    if !
[cite_start]docker info 2>/dev/null | grep -q "Swarm: active"; then [cite: 50]
        [cite_start]run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..." [cite: 50]
    else
        [cite_start]show_message "Docker Swarm ya está activo" [cite: 50]
    fi
}

create_docker_networks() {
    [cite_start]show_message "Creando redes Docker para Swarm..." [cite: 50]
    if !
[cite_start]docker network ls 2>/dev/null | grep -q "frontend"; then [cite: 51]
        [cite_start]run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..." [cite: 51]
    fi
    if !
[cite_start]docker network ls 2>/dev/null | grep -q "backend"; then [cite: 52]
        [cite_start]run_command "docker network create --driver overlay --attachable backend" "Creando red backend..." [cite: 52]
    fi
    [cite_start]INSTALLED_COMPONENTS["networks"]=true [cite: 52]
}

initialize_chatwoot_database() {
    [cite_start]show_message "Inicializando base de datos de Chatwoot (Proceso avanzado, FIX garantizado V4.9)..." [cite: 52]
    [cite_start]local container_id=$(docker ps -q --filter "name=redis_redis-server") [cite: 53]
    if [ -z "$container_id" ];
[cite_start]then show_error "Redis no está desplegado."; return 1; fi [cite: 53]
    [cite_start]run_command "docker volume create --driver local --opt type=none --opt device=$DOCKER_DIR/chatwoot/postgres_data --opt o=bind chatwoot_postgres" "Creando volumen temporal para la inicialización de Chatwoot DB..." [cite: 53]
    [cite_start]local init_stack_file="/tmp/chatwoot-init-stack.yml" [cite: 53]
    
    # Creación del stack temporal (sin cambios de lógica)
    [cite_start]cat > "$init_stack_file" << EOF_INIT [cite: 53]
version: '3.8'
services:
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
     
    - [cite_start]POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C [cite: 54]
    volumes: [chatwoot_postgres:/var/lib/postgresql/data]
    deploy: {replicas: 1, placement: {constraints: [node.role == manager]}}
    networks: [backend]
  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command: ["/bin/sh", "-c", "sleep 15 && bundle exec rails db:chatwoot_prepare"]
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
  
    - [cite_start]RAILS_ENV=production [cite: 55]
      - [cite_start]NODE_ENV=production [cite: 55]
    networks: [backend]
    [cite_start]depends_on: [chatwoot-postgres] [cite: 55]
    [cite_start]deploy: {restart_policy: {condition: none}, placement: {constraints: [node.role == manager]}} [cite: 55]
networks:
  [cite_start]backend: {external: true} [cite: 55]
volumes:
  [cite_start]chatwoot_postgres: {external: true} [cite: 55]
EOF_INIT
    [cite_start]register_temp_file "$init_stack_file" [cite: 55]
    [cite_start]run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack de inicialización temporal..." [cite: 55]
    [cite_start]show_message "Esperando a que el servicio de inicialización de Chatwoot complete su tarea..." [cite: 55]
    
    # Bucle de espera sin spinner
    [cite_start]local init_complete=false; [cite: 56]
[cite_start]local max_wait=900; local wait_time=0 [cite: 56]
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ];
[cite_start]do [cite: 57]
        [cite_start]local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1) [cite: 57]
        if echo "$service_status" |
[cite_start]grep -q "Complete"; then init_complete=true; show_success "Inicialización completada."; break [cite: 58]
        elif echo "$service_status" |
[cite_start]grep -q "Failed" || echo "$service_status" | grep -q "Shutdown"; [cite: 59, 60]
then
            [cite_start]show_error "La inicialización de la base de datos falló." [cite: 60]
[cite_start]show_message "Extrayendo logs del servicio fallido chatwoot-init_chatwoot-init..." [cite: 61]
            [cite_start]docker service logs chatwoot-init_chatwoot-init --tail 50 [cite: 61]
            [cite_start]break [cite: 61]
        fi
        [cite_start]sleep 10; [cite: 61]
[cite_start]wait_time=$((wait_time + 10)) [cite: 62]
        [cite_start]show_message "Estado actual del inicializador: $service_status (Esperando $wait_time de $max_wait segundos)" [cite: 62]
    done
    [cite_start]run_command "docker stack rm chatwoot-init" "Limpiando stack temporal de inicialización..." [cite: 62]
    [cite_start]sleep 10 [cite: 62]
    [cite_start]show_message "Intentando eliminar el volumen temporal 'chatwoot_postgres' de forma robusta..." [cite: 62]
    [cite_start]local volume_removed=false; [cite: 63]
[cite_start]local attempts=0; local max_attempts=6 [cite: 63]
    while [ "$volume_removed" = false ] && [ $attempts -lt $max_attempts ];
[cite_start]do [cite: 64]
        if docker volume rm chatwoot_postgres 2>/dev/null; then volume_removed=true; show_success "Volumen temporal eliminado.";
[cite_start]break [cite: 65]
        [cite_start]else show_warning "Volumen 'chatwoot_postgres' aún en uso. Reintentando en 5 segundos (Intento $((attempts + 1)) de $max_attempts)..."; [cite: 65, 66]
[cite_start]sleep 5; attempts=$((attempts + 1)); fi [cite: 66]
    done
    if [ "$init_complete" = true ];
[cite_start]then return 0; else return 1; fi [cite: 67]
}

install_docker_tool() {
    [cite_start]local tool_name=$1 [cite: 67]
    [cite_start]local default_subdomain=$2 [cite: 67]
    [cite_start]show_message "Configurando $tool_name..." [cite: 67]
    [cite_start]local tool_dir="$DOCKER_DIR/$tool_name" [cite: 68]
    [cite_start]mkdir -p $tool_dir; [cite: 68]
cd $tool_dir || { show_error "No se pudo acceder a $tool_dir"; cleanup 1;
[cite_start]} [cite: 69]
    [cite_start]local tool_index=-1 [cite: 69]
    for i in "${!AVAILABLE_TOOLS[@]}"; do if [ "${AVAILABLE_TOOLS[$i]}" = "$tool_name" ];
[cite_start]then tool_index=$i; break; fi; done [cite: 70]
    [cite_start]read -p "Ingrese el subdominio para $tool_name [$default_subdomain]: " SUBDOMAIN [cite: 70]
    [cite_start]SUBDOMAIN=${SUBDOMAIN:-$default_subdomain} [cite: 70]
    [cite_start]CUSTOM_SUBDOMAINS[$tool_index]=$SUBDOMAIN [cite: 70]
    [cite_start]local subdomain_file="$tool_dir/.subdomain" [cite: 70]
    [cite_start]echo "$SUBDOMAIN" > "$subdomain_file"; [cite: 71]
[cite_start]register_temp_file "$subdomain_file" [cite: 71]
    [cite_start]local stack_file="$tool_dir/$tool_name-stack.yml" [cite: 71]
    [cite_start]download_stack_content "$tool_name" "$stack_file" [cite: 71]
    [cite_start]local deploy_file="$tool_dir/$tool_name-deploy.yml" [cite: 71]
    [cite_start]cp "$stack_file" "$deploy_file"; [cite: 72]
[cite_start]register_temp_file "$deploy_file" [cite: 72]
    [cite_start]show_message "Aplicando sanitización de variables en el stack de despliegue..." [cite: 72]
    [cite_start]sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$deploy_file"; [cite: 73]
[cite_start]sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$deploy_file" [cite: 73]
    [cite_start]sed -i "s|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; [cite: 74]
[cite_start]sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file" [cite: 74]
    [cite_start]sed -i "s|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; [cite: 75]
[cite_start]sed -i "s|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file" [cite: 75]
    if [ "$tool_name" == "redis" ];
[cite_start]then [cite: 76]
        [cite_start]show_message "Aplicando **corrección crítica de configuración V4.7: Eliminando comando de Redis**." [cite: 76]
[cite_start]sed -i '/command:/d' "$deploy_file"; show_success "Corrección de Redis V4.7 aplicada." [cite: 77]
    fi
    if [ "$tool_name" == "postgres" ];
[cite_start]then [cite: 78]
        [cite_start]show_message "Aplicando corrección de variable de entorno para PostgreSQL." [cite: 78]
[cite_start]sed -i "s/POSTGRES_PASSWORD: .*/POSTGRES_PASSWORD: \$COMMON_PASSWORD/g" "$deploy_file"; show_success "Corrección de PostgreSQL aplicada." [cite: 79, 80]
fi
    [cite_start]local volume_paths=$(grep -oP "device: \K/[^\s]+" "$deploy_file" | sort | uniq) [cite: 80]
    for path in $volume_paths;
[cite_start]do run_command "mkdir -p \"$path\"" "Creando directorio $path..."; done [cite: 81]
    if [ "$tool_name" = "chatwoot" ];
[cite_start]then [cite: 82]
        [cite_start]show_message "Chatwoot detectado - Ejecutando inicialización de base de datos..." [cite: 82]
        if !
[cite_start]docker service ls | grep -q "redis_redis"; then show_error "Redis no está desplegado."; cleanup 1; [cite: 83, 84]
fi
        [cite_start]if initialize_chatwoot_database; then show_success "Base de datos de Chatwoot inicializada."; [cite: 84, 85]
[cite_start]else show_error "Error crítico al inicializar DB de Chatwoot."; cleanup 1; [cite: 86]
fi
        [cite_start]run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name (Stack Final)..." [cite: 86]
    else
        [cite_start]run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name..." [cite: 86]
    fi
    if [ "$tool_name" = "redis" ] ||
[cite_start][ "$tool_name" = "postgres" ]; then [cite: 87]
        if ! wait_for_service "$tool_name";
[cite_start]then show_error "El stack $tool_name no se estabilizó. **FALLO CRÍTICO.**"; cleanup 1; [cite: 88, 89]
fi
    fi
    [cite_start]show_success "$tool_name instalado correctamente en Docker Swarm" [cite: 89]
    [cite_start]INSTALLED_COMPONENTS["$tool_name"]=true [cite: 89]
    cd $DOCKER_DIR ||
[cite_start]{ show_error "No se pudo volver al directorio principal $DOCKER_DIR"; cleanup 1; [cite: 90, 91]
}
}


# ----------------------------------------------------
# Flujo Principal
# ----------------------------------------------------
main() {
    [cite_start]echo -e "\n${GREEN}=======================================================${NC}" [cite: 91]
    [cite_start]echo -e "${GREEN}  🚀 INSTALADOR DOCKER STANDALONE (V5.2 - MODO VERBOSE) 🚀  ${NC}" [cite: 91]
    [cite_start]echo -e "${GREEN}  👀 Muestra TODO el proceso de ejecución y logs.     ${NC}" [cite: 91]
    [cite_start]echo -e "${GREEN}=======================================================${NC}\n" [cite: 91]

    if [ "$EUID" -ne 0 ];
[cite_start]then show_error "Este script debe ejecutarse como root."; cleanup 1; exit 1; fi [cite: 92]
    [cite_start]mkdir -p $DOCKER_DIR; [cite: 93]
cd $DOCKER_DIR || { show_error "No se pudo acceder a $DOCKER_DIR"; cleanup 1; exit 1;
[cite_start]} [cite: 94]

    [cite_start]show_message "Configuración inicial" [cite: 94]
    [cite_start]read -sp "Ingrese la contraseña común para todas las herramientas: " COMMON_PASSWORD [cite: 94]
    [cite_start]echo [cite: 94]
    if [ -z "$COMMON_PASSWORD" ];
[cite_start]then show_error "La contraseña no puede estar vacía"; cleanup 1; exit 1; [cite: 95, 96]
fi
    [cite_start]read -p "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN [cite: 96]
    if [ -z "$BASE_DOMAIN" ];
[cite_start]then show_error "El dominio no puede estar vacío"; cleanup 1; exit 1; [cite: 97, 98]
fi
    [cite_start]DEFAULT_SECRET_KEY=$(generate_random_key) [cite: 98]
    [cite_start]read -p "Ingrese una clave secreta de 32 caracteres (o Enter para usar la generada): " SECRET_KEY [cite: 98]
    [cite_start]SECRET_KEY=${SECRET_KEY:-$DEFAULT_SECRET_KEY} [cite: 98]
    if [ ${#SECRET_KEY} -ne 32 ];
then show_warning "Clave proporcionada no tiene 32 caracteres. Usando la generada."; [cite_start]SECRET_KEY=$DEFAULT_SECRET_KEY; [cite: 99, 100]
fi
    [cite_start]show_message "Clave secreta utilizada: $SECRET_KEY" [cite: 100]

    [cite_start]env_global_file="$DOCKER_DIR/.env.global" [cite: 100]
    [cite_start]cat > $env_global_file << EOL [cite: 100]
COMMON_PASSWORD=$COMMON_PASSWORD
BASE_DOMAIN=$BASE_DOMAIN
SECRET_KEY=$SECRET_KEY
EOL
    [cite_start]show_success "Variables globales guardadas en $env_global_file" [cite: 100]

    [cite_start]install_dependencies [cite: 100]
    [cite_start]initialize_docker_swarm [cite: 100]
    [cite_start]create_docker_networks [cite: 100]

    [cite_start]show_message "Instalando servicios en orden de dependencias..." [cite: 100]
    [cite_start]INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot") [cite: 101]
    
    for tool_name in "${INSTALL_ORDER[@]}";
[cite_start]do [cite: 101]
        [cite_start]default_subdomain="" [cite: 101]
        for j in "${!AVAILABLE_TOOLS[@]}";
[cite_start]do [cite: 102]
            [cite_start]if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"; [cite: 103]
[cite_start]break; fi [cite: 103]
        done
        [cite_start]install_docker_tool "$tool_name" "$default_subdomain" [cite: 103]
    done

    [cite_start]echo "" [cite: 103]
    [cite_start]show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉" [cite: 103]

    [cite_start]echo "Accede a tus servicios en los siguientes URLs:" [cite: 103]
    for i in "${!SELECTED_TOOLS[@]}";
[cite_start]do [cite: 104]
        [cite_start]tool_name="${SELECTED_TOOLS[$i]}" [cite: 104]
        [cite_start]tool_index=-1 [cite: 104]
        for j in "${!AVAILABLE_TOOLS[@]}";
[cite_start]do if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then tool_index=$j; break; fi; [cite: 105, 106]
done
        if [ $tool_index -ge 0 ];
[cite_start]then [cite: 107]
            [cite_start]subdomain_file="$DOCKER_DIR/$tool_name/.subdomain" [cite: 107]
            [cite_start]subdomain="" [cite: 107]
            if [ -f "$subdomain_file" ];
[cite_start]then subdomain=$(cat "$subdomain_file"); else subdomain="${CUSTOM_SUBDOMAINS[$tool_index]:-${DEFAULT_SUBDOMAINS[$tool_index]}}"; fi [cite: 108]
            [cite_start]echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN" [cite: 108]
        fi
    done
    
    [cite_start]echo "" [cite: 108]
    [cite_start]echo "Información de credenciales:" [cite: 108]
    [cite_start]echo "- Contraseña común: $COMMON_PASSWORD" [cite: 108]
    [cite_start]echo "- Clave secreta: $SECRET_KEY" [cite: 108]
    [cite_start]echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global" [cite: 108]
    [cite_start]echo "===========================================" [cite: 108]

    [cite_start]cleanup 0 true [cite: 108]
}

# Ejecutar función principal
main
