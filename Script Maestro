#!/usr/bin/env bash
# =================================================================================
# INSTALADOR UNIFICADO DOCKER SWARM (v4.0.0 - MAESTRO FINAL KHUNTER)
# Autor: Adaptado y corregido por Gemini AI (basado en Queen Novedad / Khunter)
# Objetivo: Instalación robusta de stack Docker Swarm (Traefik, Portainer, Redis, Postgres, n8n, EvoAPI y Chatwoot)
# CORRECCIÓN CRÍTICA: Se añadió el procesamiento de archivos YAML (sed) dentro de deploy_stack
# =================================================================================

SCRIPT_VERSION="4.0.0-FINAL"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# 1. Configuración de Herramientas y URLs (ACTUALIZAR ESTAS URLS CON TU REPO DE GITHUB)
# -----------------------------------------------
# Lista de herramientas disponibles
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
# Subdominios predeterminados
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "db" "n8" "api" "chat")

# URLs para descargar los archivos docker-compose/stack.yml
# NOTA: DEBES REEMPLAZAR ESTAS URLS POR LOS ENLACES 
# CRUDOS (RAW) DE TU REPO DE GITHUB.
declare -gA STACK_URLS=(
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    # Archivos separados para la inicialización robusta de Chatwoot
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml" # Stack final
    [chatwoot-init]="https://github.com/user-attachments/files/22988211/chatwoot-init-stack.yml" # Stack temporal de inicialización
)

# -----------------------------------------------
# 2. Funciones de Utilidad
# -----------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[ADVERTENCIA]${NC} $1"; }

read_input() {
    local prompt="$1"
    local default_val="$2"
    local result_var="$3"
    
    # Si la variable de resultado no existe o está vacía, preguntar al usuario
    if [ -z "${!result_var}" ]; then
        echo -n -e "${BLUE}[PREGUNTA]${NC} $prompt (Predeterminado: $default_val): "
        read user_input
        # Si la entrada del usuario está vacía, usa el valor predeterminado
        if [ -z "$user_input" ]; then
            eval $result_var=\"$default_val\"
        else
            eval $result_var=\"$user_input\"
        fi
    fi
}

cleanup() {
    local exit_code=$1
    echo ""
    show_message "Realizando limpieza antes de salir..."
    
    if [ ${#TEMP_FILES[@]} -gt 0 ]; then
        rm -f "${TEMP_FILES[@]}" 2>/dev/null
    fi

    # Eliminar el archivo de variables temporales si no hubo éxito
    if [ $exit_code -ne 0 ] && [ -f "$DOCKER_DIR/.env.global.tmp" ]; then
        rm -f "$DOCKER_DIR/.env.global.tmp"
    fi

    show_message "Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        show_error "Instalación fallida"
    else
        show_success "Instalación completada exitosamente"
    fi

    exit $exit_code
}

trap 'cleanup 1' ERR INT TERM

# -----------------------------------------------
# 3. Funciones de Pre-instalación y Variables
# -----------------------------------------------

validate_prerequisites() {
    if ! command -v docker &> /dev/null; then
        show_error "Docker no está instalado. Por favor, instala Docker y Docker Compose."
        cleanup 1
    fi

    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        show_message "Docker Swarm no está activo. Inicializando..."
        if ! docker swarm init &> /dev/null; then
            show_error "No se pudo inicializar Docker Swarm."
            cleanup 1
        fi
        show_success "Docker Swarm inicializado."
    fi
    show_success "Requisitos de Docker validados."
}

configure_variables() {
    show_message "Configuración de variables de entorno y credenciales."
    read_input "Ingrese el dominio base (ej. midominio.com)" "" BASE_DOMAIN
    read_input "Ingrese la contraseña común para todos los servicios (ej. p4ssw0rdS3gur0)" "$(openssl rand -base64 12)" COMMON_PASSWORD
    read_input "Ingrese la clave secreta única (ej. 3ncrYptK3y)" "$(openssl rand -base64 24)" SECRET_KEY

    # Exportar variables de entorno globalmente para los comandos docker
    export BASE_DOMAIN COMMON_PASSWORD SECRET_KEY DOCKER_DIR

    # Crear y guardar el archivo .env.global
    mkdir -p "$DOCKER_DIR"
    {
        echo "BASE_DOMAIN=$BASE_DOMAIN"
        echo "COMMON_PASSWORD=$COMMON_PASSWORD"
        echo "SECRET_KEY=$SECRET_KEY"
    } > "$DOCKER_DIR/.env.global"
    show_success "Variables globales guardadas en $DOCKER_DIR/.env.global"
    
    # Selección de herramientas
    show_message "Seleccione las herramientas a instalar (separadas por espacio):"
    echo "Opciones disponibles: ${AVAILABLE_TOOLS[@]}"
    
    read -p "Su selección (ej. traefik portainer chatwoot): " USER_SELECTION
    
    # Validar y guardar la selección
    local -a selected_temp
    for tool in $USER_SELECTION; do
        if [[ " ${AVAILABLE_TOOLS[@]} " =~ " ${tool} " ]]; then
            selected_temp+=("$tool")
        else
            show_warning "Herramienta '$tool' no reconocida y será ignorada."
        fi
    done

    if [ ${#selected_temp[@]} -eq 0 ]; then
        show_error "No se seleccionó ninguna herramienta válida. Abortando."
        cleanup 1
    fi
    
    SELECTED_TOOLS=("${selected_temp[@]}")
    show_message "Herramientas seleccionadas: ${SELECTED_TOOLS[@]}"

    # Configuración de subdominios
    declare -gA CUSTOM_SUBDOMAINS
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        default_subdomain="${DEFAULT_SUBDOMAINS[$i]}"
        read_input "Ingrese el subdominio para $tool_name" "$default_subdomain" "CUSTOM_SUBDOMAINS[$tool_name]"
        
        # Guardar el subdominio seleccionado para uso posterior
        echo "${CUSTOM_SUBDOMAINS[$tool_name]}" > "$DOCKER_DIR/$tool_name/.subdomain"
        export ${tool_name^^}_SUBDOMAIN="${CUSTOM_SUBDOMAINS[$tool_name]}"
    done
}

create_networks_and_dirs() {
    show_message "Creando directorios y redes Docker Swarm..."
    
    # Crear directorios para cada herramienta y persistencia
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        mkdir -p "$DOCKER_DIR/$tool_name"
    done
    
    # Crear redes compartidas
    for network in "traefik-public" "docker-flow"; do
        if ! docker network ls | grep -q "$network"; then
            show_message "Creando red '$network'..."
            docker network create -d overlay --attachable "$network" >/dev/null
            if [ $? -ne 0 ]; then
                show_error "No se pudo crear la red $network."
                cleanup 1
            fi
        fi
    done
    show_success "Directorios y redes creados."
}

# -----------------------------------------------
# 4. Funciones de Instalación Críticas
# -----------------------------------------------

# FUNCIÓN CORREGIDA: Inicialización robusta de Chatwoot
initialize_chatwoot_database() {
    local final_stack_name="chatwoot"
    local init_stack_name="chatwoot-init"
    local postgres_volume_name="${init_stack_name}_chatwoot-postgres-data" # Nombre del volumen que crea el stack de inicialización
    
    show_message "Iniciando proceso de inicialización de Chatwoot (Stack Temporal: $init_stack_name)..."
    
    # 1. Descargar y desplegar el stack TEMPORAL de inicialización
    local temp_file="$DOCKER_DIR/$final_stack_name/${init_stack_name}.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot-init]}" -o "$temp_file"
    TEMP_FILES+=("$temp_file")
    
    # INYECCIÓN DE VARIABLES EN EL STACK DE INICIALIZACIÓN
    show_message "Inyectando variables y credenciales al stack de inicialización de Chatwoot..."
    sed -i "s|REPLACE_COMMON_PASSWORD|$COMMON_PASSWORD|g" "$temp_file"
    
    show_message "Desplegando stack temporal '$init_stack_name' para la base de datos..."
    docker stack deploy -c "$temp_file" "$init_stack_name"
    
    show_message "Esperando 45 segundos a que la base de datos de inicialización esté lista..."
    sleep 45

    # 2. Ejecutar la migración
    # Encontrar el ID del contenedor de setup de Chatwoot
    local init_container_id=$(docker service ps -q "${init_stack_name}_chatwoot-setup" --filter "desired-state=running" | head -n 1)
    
    if [ -z "$init_container_id" ]; then
        show_error "No se pudo encontrar el contenedor de setup para la inicialización. Abortando."
        cleanup 1
    fi
    
    show_message "Ejecutando la inicialización (db:setup) dentro del contenedor $init_container_id..."
    
    # El comando setup ejecuta 'rails db:setup', que inicializa la DB.
    docker service logs "${init_stack_name}_chatwoot-setup" &
    if ! docker container exec -t "$init_container_id" /bin/bash -c "RAILS_ENV=production bundle exec rails db:setup"; then
        show_warning "El comando db:setup finalizó con un código de error, pero el log de salida se usará para confirmar el éxito."
    fi

    # 3. Limpiar el stack TEMPORAL
    show_message "Eliminando el stack temporal '$init_stack_name'..."
    docker stack rm "$init_stack_name"
    show_success "Stack temporal '$init_stack_name' eliminado."
    
    # 4. CORRECCIÓN CRÍTICA: Eliminar el volumen de datos de la inicialización de forma robusta
    show_message "Intentando eliminar el volumen temporal '$postgres_volume_name' de forma robusta..."
    local attempts=0
    local max_attempts=5
    local success=0

    while [ $attempts -lt $max_attempts ]; do
        if docker volume rm "$postgres_volume_name" 2>/dev/null; then
            show_success "Volumen temporal '$postgres_volume_name' eliminado."
            success=1
            break
        else
            show_message "Intento $((attempts+1)): Volumen aún en uso o no encontrado. Esperando 5 segundos..."
            sleep 5
            attempts=$((attempts+1))
        fi
    done

    if [ $success -eq 0 ]; then
        show_error "No se pudo eliminar el volumen '$postgres_volume_name'. Debe ser eliminado manualmente más tarde."
    fi

    show_success "Base de datos de Chatwoot inicializada para el despliegue final."
    
    # 5. Desplegar el stack FINAL de Chatwoot
    local final_deploy_file="$DOCKER_DIR/$final_stack_name/${final_stack_name}-deploy.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot]}" -o "$final_deploy_file"
    TEMP_FILES+=("$final_deploy_file")
    
    show_message "Inyectando variables al stack final de Chatwoot..."
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$final_deploy_file"
    sed -i "s|REPLACE_SUBDOMAIN|${CUSTOM_SUBDOMAINS[chatwoot]}|g" "$final_deploy_file"
    sed -i "s|REPLACE_COMMON_PASSWORD|$COMMON_PASSWORD|g" "$final_deploy_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$final_deploy_file"

    show_message "Desplegando chatwoot (Stack Final: $final_stack_name)..."
    docker stack deploy -c "$final_deploy_file" "$final_stack_name"
    
    show_success "Comando completado exitosamente."
}

deploy_stack() {
    local tool_name="$1"
    local default_subdomain="$2"

    show_message "Iniciando instalación de $tool_name..."
    
    # 1. Descargar Stack File
    local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[$tool_name]}" -o "$stack_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el archivo stack para $tool_name. Revisar URL: ${STACK_URLS[$tool_name]}"
        return 1
    fi
    TEMP_FILES+=("$stack_file")

    # 2. PROCESAMIENTO CRÍTICO DEL ARCHIVO YAML (INYECCIÓN DE VARIABLES Y CORRECCIONES)
    show_message "Aplicando configuración y credenciales a $tool_name-stack.yml..."

    # a) Reemplazo global de variables
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$stack_file"
    sed -i "s|REPLACE_SUBDOMAIN|${CUSTOM_SUBDOMAINS[$tool_name]}|g" "$stack_file"
    sed -i "s|REPLACE_COMMON_PASSWORD|$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$stack_file"

    # b) Correcciones específicas por herramienta
    if [ "$tool_name" == "redis" ]; then
        show_message "Aplicando corrección de comando y volumen para Redis..."
        # 1. Agrega la contraseña al comando de ejecución (Soluciona el error 'wrong number of arguments')
        sed -i "s/command: redis-server --loglevel warning/command: redis-server --requirepass $COMMON_PASSWORD --loglevel warning/g" "$stack_file"
        # 2. Asegura la definición de variables en RedisInsight
        sed -i '/image: redislabs\/redisinsight:latest/a\    environment:\n      - REDISINSIGHT_PASSWORD='$COMMON_PASSWORD'\n      - REDIS_PASSWORD='$COMMON_PASSWORD'' "$stack_file"
        # NOTA: Los problemas de volumen deben corregirse directamente en el YML del repo, usando Named Volume.
    fi

    if [ "$tool_name" == "evoapi" ]; then
        show_message "Aplicando corrección de credenciales para EvoAPI..."
        # 1. Inyecta la contraseña directamente en la DATABASE_URL (Soluciona el error P1000)
        sed -i "s/postgres:\${COMMON_PASSWORD}/postgres:$COMMON_PASSWORD/g" "$stack_file"
        # 2. Asegura que la DB de EvoAPI tenga la contraseña
        sed -i "s/\(POSTGRES_PASSWORD=\).*/\1$COMMON_PASSWORD/g" "$stack_file"
    fi

    show_success "Configuración aplicada."
    
    # 3. Despliegue del Stack
    docker stack deploy -c "$stack_file" "$tool_name"
    
    if [ $? -ne 0 ]; then
        show_error "Error al desplegar el stack $tool_name."
        return 1
    fi
    show_success "Stack $tool_name desplegado."
    
    # 4. Post-instalación (esperas para estabilidad)
    if [ "$tool_name" == "redis" ] || [ "$tool_name" == "postgres" ]; then
        show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
        sleep 15
    fi

    return 0
}

# -----------------------------------------------
# 5. Flujo Principal
# -----------------------------------------------

main_installation() {
    validate_prerequisites
    configure_variables

    # Desplegar Traefik (debe ser el primero)
    if [[ " ${SELECTED_TOOLS[@]} " =~ " traefik " ]]; then
        create_networks_and_dirs # Asegura que las redes están creadas antes de Traefik
        deploy_stack "traefik" "${CUSTOM_SUBDOMAINS[traefik]}" || cleanup 1
        
        # Espera extra para Traefik para que los certificados se provisionen
        show_message "Esperando 30 segundos para el provisionamiento inicial de Traefik y Let's Encrypt..."
        sleep 30 
    else
        show_error "El stack Traefik es obligatorio. Por favor, inclúyelo en la selección."
        cleanup 1
    fi

    # Desplegar el resto de herramientas
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        default_subdomain="${CUSTOM_SUBDOMAINS[$tool_name]}"

        # Ya desplegamos Traefik
        if [ "$tool_name" == "traefik" ]; then
            continue
        fi

        # Lógica especial para Chatwoot (con inicialización de DB corregida)
        if [ "$tool_name" == "chatwoot" ]; then
            initialize_chatwoot_database
        else
            deploy_stack "$tool_name" "$default_subdomain" || cleanup 1
        fi
    done

    # 6. Mensaje final y limpieza
    finalize_installation
}

finalize_installation() {
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    show_message "Verifique que todos los servicios estén en estado '1/1' con 'docker service ls'."
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${CUSTOM_SUBDOMAINS[$tool_name]}"
        fi

        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común (para Portainer, n8n, EvoAPI, Chatwoot, DBs): $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"
    
    cleanup 0
}

# Ejecutar el script
main_installation
