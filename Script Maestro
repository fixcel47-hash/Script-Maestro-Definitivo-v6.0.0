#!/usr/bin/env bash
# =================================================================================
# SCRIPT MAESTRO DEFINITIVO PÃšBLICO (v6.0.4 - CORRECCIÃ“N DE SINTAXIS N8N)
# ðŸš¨ REQUIERE: Las siguientes variables de entorno DEBEN exportarse antes de ejecutar:
#    export INSTALL_PASSWORD="TU_CONTRASEÃ‘A"
#    export INSTALL_DOMAIN="TU_DOMINIO.COM"
#    export INSTALL_SECRET_KEY="TU_CLAVE_SECRETA_DE_32_CARACTERES" (Opcional)
# =================================================================================

set -euo pipefail

SCRIPT_VERSION="6.0.4-PUBLIC-MASTER"

# Colores y Utilidades
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'; BLUE='\033[0;34m'; NC='\033[0m'
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }
register_temp_file() { TEMP_FILES+=("$1"); }

# Variables Globales
SUDO=""
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30
declare -a CUSTOM_SUBDOMAINS
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

# Definiciones de Herramientas y URLs
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")

# -------------------------------
# FUNCIONES DE EJECUCIÃ“N Y LIMPIEZA
# -------------------------------

run_command() {
    local cmd="$1"
    local msg="$2"
    
    show_message "$msg"
    
    local full_cmd
    if [ -n "$SUDO" ] && [[ "$cmd" != docker* ]] && [[ "$cmd" != *"$SUDO"* ]]; then
        full_cmd="$SUDO $cmd"
    else
        full_cmd="$cmd"
    fi
    
    echo -e "  -> Ejecutando: \033[0;33m$full_cmd\033[0m"

    # V6.0.2: Usamos 'eval' para interpretar pipes y redirecciones.
    if eval "$full_cmd"; then 
        show_success "Completado: $msg"
        return 0
    else
        local exit_status=$?
        show_error "Comando fallÃ³ con cÃ³digo $exit_status: $full_cmd"
        return $exit_status
    fi
}

cleanup() {
    local exit_code=$1; local delete_stacks=${2:-false} 
    show_message "Realizando limpieza antes de salir..."
    
    if [ ${#TEMP_FILES[@]} -gt 0 ]; then
        for file in "${TEMP_FILES[@]}"; do
            if [ -f "$file" ]; then $SUDO rm -f "$file"; fi
        done
    fi
    
    if [ "$delete_stacks" = true ]; then
        show_message "Eliminando stacks de Docker Swarm..."
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            run_command "docker stack rm $tool_name" "Eliminando stack $tool_name..." || true
            local tool_dir="$DOCKER_DIR/$tool_name"
            $SUDO rm -f "$tool_dir/."subdomain "$tool_dir/$tool_name-deploy.yml" "$tool_dir/$tool_name-stack.yml.raw"
        done
        $SUDO rm -f "$DOCKER_DIR/.env.global"
    fi
    
    if [ $exit_code -ne 0 ]; then show_error "La instalacion ha fallado. Revise los logs para mas informacion."; fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    show_message "Limpieza completada"
}

trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false; exit 1' ERR

# -------------------------------
# FUNCIONES DE INSTALACIÃ“N BASE
# -------------------------------

install_dependencies() {
    show_message "Verificando e instalando dependencias (curl, wget, jo, perl, Docker)..."
    run_command "apt-get update -y" "Actualizando lista de paquetes..."
    run_command "apt-get install -y ca-certificates curl gnupg lsb-release apt-transport-https software-properties-common jo perl" "Instalando utilidades y requisitos..."

    if ! command -v docker &> /dev/null; then
        local OS_DETECTED
        if [ -f /etc/os-release ]; then . /etc/os-release; OS_DETECTED=$ID; else OS_DETECTED="debian"; fi
        
        show_message "Instalando Docker..."
        $SUDO install -m 0755 -d /etc/apt/keyrings
        run_command "curl -fsSL https://download.docker.com/linux/$OS_DETECTED/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg" "Descargando clave GPG de Docker..."
        echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS_DETECTED \
$(lsb_release -cs) stable" | $SUDO tee /etc/apt/sources.list.d/docker.list > /dev/null
        run_command "apt-get update -y && apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
    else
        show_success "Docker ya estÃ¡ instalado."
    fi
    
    run_command "systemctl enable docker" "Habilitando servicio Docker..."
    run_command "systemctl start docker" "Iniciando servicio Docker..."
    
    local config_file="/etc/docker/daemon.json"
    $SUDO cat > "$config_file" <<EOF
{
  "log-driver": "json-file", "log-opts": {"max-size": "10m", "max-file": "3"}
}
EOF
    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuraciÃ³n de logs..."
    
    initialize_docker_swarm 
}

initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
    else
        show_warning "Docker Swarm ya esta activo"
    fi
}

install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    # ConfiguraciÃ³n de seguridad (Fail2Ban, RKHunter, UFW)
    run_command "apt-get install -y fail2ban && systemctl enable fail2ban && systemctl start fail2ban" "Instalando y activando Fail2Ban..."
    run_command "apt-get install -y rkhunter" "Instalando RKHunter..."
    
    local config_file="/etc/rkhunter.conf"
    run_command "$SUDO sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && $SUDO sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && $SUDO sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" "Configurando RKHunter..."
    
    # V6.0.3 CORRECCIÃ“N: Tolerancia a fallos de RKHunter --update.
    if ! run_command "rkhunter --update" "Actualizando RKHunter..."; then
        show_warning "La actualizacion de RKHunter fallo. Se continua la instalacion."
    fi
    
    # V6.0.3 CORRECCIÃ“N: Tolerancia a fallos de RKHunter --propupd.
    if ! run_command "rkhunter --propupd" "Actualizando base de datos de propiedades de RKHunter..."; then
        show_warning "La actualizacion de propiedades de RKHunter fallo. Se continua la instalacion."
    fi
    
    run_command "apt-get install -y chkrootkit" "Instalando CHKRootkit..."
    run_command "apt-get install -y ufw" "Instalando UFW..."
    run_command "ufw allow ssh && ufw allow http && ufw allow https && echo 'y' | ufw enable" "Configurando y activando reglas bÃ¡sicas de UFW..."
    show_success "Herramientas de seguridad instaladas correctamente"
}

create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
    else
        show_warning "La red 'frontend' ya existe"
    fi
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
    else
        show_warning "La red 'backend' ya existe"
    fi
}

# -------------------------------
# FUNCIONES DE DESPLIEGUE
# -------------------------------

download_file() {
    local url="$1" file="$2"
    show_message "Descargando $url -> $file"
    local download_cmd
    if command -v curl >/dev/null 2>&1; then download_cmd="curl --fail --location --max-time ${DOWNLOAD_TIMEOUT} -sS '$url' -o '$file'";
    elif command -v wget >/dev/null 2>&1; then download_cmd="wget -q --timeout=${DOWNLOAD_TIMEOUT} -O '$file' '$url'";
    else show_error "Ni curl ni wget estan disponibles."; return 3; fi
    if ! eval "$download_cmd"; then show_error "Fallo al descargar $url"; return 2; fi
    show_success "Descargado: $file"
    return 0
}

sanitize_yaml() {
    local infile="$1" outfile="$2"
    cp -f "$infile" "${infile}.raw" 
    cp -f "$infile" "$outfile"
    show_message "Saneando $outfile de secretos..."
    # Reemplaza claves largas por marcador para Portainer
    perl -0777 -pi -e 's/([A-Z_]+)\s*[:=]\s*([A-Za-z0-9_\-\.\/]{32,})/\1: <REPLACE_ME>/g' "$outfile" || true
    show_success "Saneado: $outfile"
}

create_volume_directories() {
    local stack_file=$1 tool_name=$2
    show_message "Creando directorios para volÃºmenes de $tool_name..."
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)
    for path in $volume_paths; do run_command "mkdir -p \"$path\"" "Creando directorio $path..."; done
}

# LÃ³gica de Chatwoot 
initialize_chatwoot_database() {
    local tool_name="chatwoot"
    local subdomain=$1
    
    show_message "Inicializando base de datos de Chatwoot (VerificaciÃ³n y Despliegue Temporal)..."
    
    # 1. Verificar Redis 
    show_message "Verificando disponibilidad de Redis..."
    local redis_ready=false; local max_attempts=60; local attempt=0; local container_id
    container_id=$(docker ps --filter "name=redis_redis" --format "{{.ID}}" | head -n 1)
    while [ $attempt -lt $max_attempts ] && [ "$redis_ready" = false ]; do
        if [ -n "$container_id" ]; then
            if docker exec "$container_id" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                redis_ready=true; show_success "Redis estÃ¡ listo"; break
            fi
        fi
        sleep 5; attempt=$((attempt + 1));
        container_id=$(docker ps --filter "name=redis_redis" --format "{{.ID}}" | head -n 1)
    done
    if [ "$redis_ready" = false ]; then show_error "Redis no estÃ¡ disponible"; return 1; fi 
    
    # 2. Crear y desplegar stack temporal para inicializaciÃ³n
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    $SUDO cat > "$init_stack_file" << EOF
version: '3.8'
services:
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    volumes:
      - chatwoot_postgres:/var/lib/postgresql/data
    deploy:
      replicas: 1
      restart_policy: {condition: on-failure}
      placement: {constraints: [node.role == manager]}
    networks: [backend]
  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command: ["bundle", "exec", "rails", "db:chatwoot_prepare"]
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
      - RAILS_ENV=production
      - NODE_ENV=production
    networks: [backend]
    depends_on: [chatwoot-postgres]
    deploy: {restart_policy: {condition: none}; placement: {constraints: [node.role == manager]}}
networks: {backend: {external: true}}
volumes: {chatwoot_postgres: {driver: local; driver_opts: {type: none; device: /home/docker/chatwoot/postgres_data; o: bind}}}
EOF
    register_temp_file "$init_stack_file"
    run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack temporal para inicializaciÃ³n..."
    
    # 3. Esperar a que la base de datos estÃ© lista y la inicializaciÃ³n termine (MÃ¡x 10 minutos)
    local init_complete=false; local max_wait=600; local wait_time=0;
    show_message "Esperando inicializaciÃ³n de base de datos (MÃ¡x 10 minutos)..."
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
        if echo "$service_status" | grep -q "Complete"; then init_complete=true; break
        elif echo "$service_status" | grep -q "Failed"; then show_error "La inicializaciÃ³n fallÃ³"; break; fi
        sleep 10; wait_time=$((wait_time + 10));
    done
    
    # 4. Limpiar stack y finalizar
    show_message "Limpiando stack de inicializaciÃ³n..."
    docker stack rm chatwoot-init >/dev/null 2>&1; sleep 15
    
    if [ "$init_complete" = true ]; then show_success "Base de datos de Chatwoot inicializada correctamente"; return 0;
    else show_error "La inicializaciÃ³n de la base de datos no se completÃ³"; return 1; fi
}

install_docker_tool() {
    local tool_name=$1; local default_subdomain=$2; local tool_index=$3

    show_message "Configurando $tool_name..."
    local tool_dir="$DOCKER_DIR/$tool_name"
    run_command "mkdir -p \"$tool_dir\"" "Creando directorio de la herramienta..."
    cd "$tool_dir" || exit 1
    
    # Subdominio no interactivo
    SUBDOMAIN=$default_subdomain
    CUSTOM_SUBDOMAINS[$tool_index]=$SUBDOMAIN
    subdomain_file="$tool_dir/.subdomain"; echo "$SUBDOMAIN" > "$subdomain_file"; register_temp_file "$subdomain_file"

    local stack_url="${STACK_URLS[$tool_name]}"; local stack_file="$tool_dir/$tool_name-stack.yml"; local deploy_file="$tool_dir/$tool_name-deploy.yml"

    if ! download_file "$stack_url" "$stack_file"; then exit 1; fi
    sanitize_yaml "$stack_file" "$deploy_file"; register_temp_file "$deploy_file"
    
    # V6.0.4 CORRECCIÃ“N: SustituciÃ³n de valores sensibles usando comillas simples 
    # para evitar errores de sintaxis YAML (como el error 'must be a string' en n8n).
    perl -pi -e "s|<REPLACE_ME>|'$COMMON_PASSWORD'|g" "$deploy_file"
    perl -pi -e "s|REPLACE_PASSWORD|'$COMMON_PASSWORD'|g" "$deploy_file"
    perl -pi -e "s|REPLACE_SECRET_KEY|'$SECRET_KEY'|g" "$deploy_file"
    
    # SustituciÃ³n de dominio (no necesita comillas, ya debe estar en el stack)
    sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"


    create_volume_directories "$deploy_file" "$tool_name"
    
    if [ "$tool_name" = "chatwoot" ]; then
        if ! initialize_chatwoot_database "$SUBDOMAIN"; then exit 1; fi
    fi
    
    run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name..."
    cd "$DOCKER_DIR" || exit 1
}

# -------------------------------
# FLUJO PRINCIPAL (main)
# -------------------------------

# Chequeo de Root (Ejecutado al principio, fuera de main)
echo "=== Instalador Universal v$SCRIPT_VERSION ==="
if [ "$(id -u)" -ne 0 ]; then
    if ! command -v sudo &> /dev/null; then show_error "No eres root y 'sudo' no esta instalado."; exit 1; fi
    SUDO="sudo"; show_message "Ejecutando con sudo...";
else
    SUDO=""; show_message "Ejecutando como root...";
fi
if [ -f /etc/os-release ]; then . /etc/os-release; show_message "Sistema detectado: $PRETTY_NAME"; else show_error "No se pudo detectar el sistema operativo."; exit 1; fi


main() {
    
    # âš ï¸ VALIDACIÃ“N CRÃTICA DE VARIABLES DE ENTORNO PÃšBLICAS
    if [ -z "${INSTALL_PASSWORD:-}" ]; then show_error "âŒ ContraseÃ±a no definida. Exporta INSTALL_PASSWORD (obligatorio)."; exit 1; fi
    if [ -z "${INSTALL_DOMAIN:-}" ]; then show_error "âŒ Dominio no definido. Exporta INSTALL_DOMAIN (obligatorio)."; exit 1; fi
    
    COMMON_PASSWORD="${INSTALL_PASSWORD}"
    BASE_DOMAIN="${INSTALL_DOMAIN}"
    SECRET_KEY="${INSTALL_SECRET_KEY:-$(generate_random_key)}" # Genera si no se proporciona

    show_message "Configuracion (ENV VARS): ContraseÃ±a: ***, Dominio: $BASE_DOMAIN, Clave Secreta: $SECRET_KEY"

    # Intentar limpiar la instalaciÃ³n fallida de n8n antes de continuar
    show_message "Limpiando instalaciÃ³n fallida de n8n para reintentar..."
    docker stack rm n8n >/dev/null 2>&1 || true
    rm -rf "$DOCKER_DIR/n8n"

    run_command "mkdir -p \"$DOCKER_DIR\"" "Creando directorio principal..."
    cd "$DOCKER_DIR" || exit 1

    # Guardar variables en .env.global
    env_global_file="$DOCKER_DIR/.env.global"
    $SUDO cat > "$env_global_file" << EOL
COMMON_PASSWORD=$COMMON_PASSWORD
BASE_DOMAIN=$BASE_DOMAIN
SECRET_KEY=$SECRET_KEY
EOL
    register_temp_file "$env_global_file"

    # InstalaciÃ³n de dependencias y servicios base
    install_dependencies
    install_server_tools
    create_docker_networks

    # InstalaciÃ³n de herramientas en orden (Dependencias primero)
    INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot")
    show_message "Iniciando despliegue de stacks en Docker Swarm..."
    
    for tool_name in "${INSTALL_ORDER[@]}"; do
        default_subdomain=""
        tool_index=-1
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
                default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"
                tool_index=$j
                break
            fi
        done

        if [ $tool_index -ge 0 ]; then
            install_docker_tool "$tool_name" "$default_subdomain" "$tool_index"
            
            # Pausa para estabilizaciÃ³n
            if [ "$tool_name" = "postgres" ] || [ "$tool_name" = "redis" ]; then
                show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
                sleep 15
            fi
        fi
    done

    # Resumen y FinalizaciÃ³n
    echo ""
    show_success "Â¡Instalacion completada! Accede a tus servicios:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        local tool_name="${SELECTED_TOOLS[$i]}"
        local tool_index=-1
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
                tool_index=$j
                break
            fi
        done

        if [ $tool_index -ge 0 ]; then
            local subdomain="${CUSTOM_SUBDOMAINS[$tool_index]}"
            echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN"
        fi
    done

    echo "Credenciales guardadas en: $DOCKER_DIR/.env.global"
    
    cleanup 0 true
}

main
