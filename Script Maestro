#!/bin/sh

# Versin 2.2.0: Optimizado para /bin/sh para evitar el error 'No such file or directory' de Bash.

SCRIPT_VERSION="2.2.0" 

# Colores para mensajes (sintaxis compatible con SH)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Variables
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES="" 

# Funciones de mensaje (simplificadas)
show_message() { echo "${BLUE}[INFO]${NC} $1"; }
show_error() { echo "${RED}[ERROR]${NC} $1"; }
show_success() { echo "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo "${YELLOW}[WARNING]${NC} $1"; }

# Funcin para registrar un archivo temporal para limpieza posterior
register_temp_file() {
    TEMP_FILES="$TEMP_FILES $1"
}

# Funcin de limpieza
cleanup() {
    local exit_code=$1
    
    show_message "Realizando limpieza antes de salir..."
    
    if [ "$exit_code" -ne 0 ]; then
        show_error "Error detectado durante la instalacin. Limpiando archivos temporales..."
        
        # Eliminar archivos temporales
        for file in $TEMP_FILES; do
            if [ -f "$file" ]; then
                rm -f "$file"
            fi
        done
    fi
    
    # Crear un script de autodestruccin (solo para limpieza de s mismo)
    local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
    cat > "$self_destruct_script" << EOF
#!/bin/sh
sleep 1
# Eliminar el script de instalacin
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
# Eliminar este script de autodestruccin
rm -f "\$0"
EOF

    chmod +x "$self_destruct_script"
    # Ejecutar en segundo plano
    ( nohup "$self_destruct_script" >/dev/null 2>&1 & )

    show_message "Limpieza completada"
    
    if [ "$exit_code" -ne 0 ]; then
        show_error "La instalacin ha fallado. Revise los logs para ms informacin."
    else
        show_success "Instalacin completada exitosamente"
    fi
}

# Configurar trampas para seales para limpiar antes de salir
trap 'cleanup 1; exit 1' 1 2 3 15 

# Funcin para animacin de espera (simplificada)
spinner() {
    local pid=$1
    local spinstr='|/-\'
    
    echo "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c] \r" "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep 0.1
    done
    printf "      \r"
    echo "${GREEN}[COMPLETADO]${NC}"
}

# Funcin para ejecutar comandos mostrando animacin de espera
run_command() {
    local cmd="$1"
    local msg="$2"
    
    show_message "$msg"
    # Ejecutamos el comando directamente sin eval, lo cual es ms seguro
    ( $cmd ) > /dev/null 2>&1 &
    local cmd_pid=$!
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    
    if [ "$exit_status" -ne 0 ]; then
        show_error "Comando fall: $cmd"
        cleanup 1
        exit "$exit_status"
    fi
    
    return "$exit_status"
}

# Funcin para generar clave aleatoria de 32 caracteres (compatible con SH)
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# Funcin para configurar tamao de los logs de Docker
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"
    show_message "Configurando lmites de logs en Docker..."
    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF
    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuracin..."
}

# Funcin para configurar rkhunter
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"
    show_message "Configurando RKHunter..."
    # Se utiliza sed compatible con SH
    run_command "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
                sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                "Aplicando configuracin de RKHunter..."
}

# Funcin para crear archivos de stack localmente (Embedded YAML)
create_stack_file_locally() {
    local tool_name=$1
    local local_path=$2

    show_message "Creando archivo de stack localmente para $tool_name..."
    
    case "$tool_name" in
        traefik)
            cat > "$local_path" << 'TRAEFIK_EOF'
version: '3.8'

services:
  traefik:
    image: traefik:v3.0
    command:
      - --api.insecure=false
      - --providers.docker.swarmMode=true
      - --providers.docker.exposedbydefault=false
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --certificatesresolvers.letsencrypt.acme.email=admin@$BASE_DOMAIN_REPLACE
      - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json
      - --certificatesresolvers.letsencrypt.acme.caserver=https://acme-v02.api.letsencrypt.org/directory
    ports:
      - target: 80
        published: 80
        protocol: tcp
        mode: host
      - target: 443
        published: 443
        protocol: tcp
        mode: host
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_letsencrypt:/letsencrypt
    deploy:
      mode: global
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.traefik-secure.entrypoints=websecure
        - traefik.http.routers.traefik-secure.rule=Host(`proxy.$BASE_DOMAIN_REPLACE`)
        - traefik.http.routers.traefik-secure.service=api@internal
        - traefik.http.routers.traefik-secure.middlewares=auth-traefik@docker
        - traefik.http.routers.traefik-secure.tls.certresolver=letsencrypt
        # Usuario: admin, ContraseÃ±a: admin_password (Hash: $$apr1$$7t.l320O$$07v1/Ym2fJz2hR19L05xI.)
        - traefik.http.middlewares.auth-traefik.basicauth.users=admin:$$apr1$$7t.l320O$$07v1/Ym2fJz2hR19L05xI.
    networks:
      - frontend

volumes:
  traefik_letsencrypt:
    driver: local
    driver_opts:
      type: none
      device: $DOCKER_DIR/traefik/letsencrypt
      o: bind

networks:
  frontend:
    external: true
TRAEFIK_EOF
            ;;
        portainer)
            cat > "$local_path" << 'PORTAINER_EOF'
version: '3.8'

services:
  portainer:
    image: portainer/portainer-ce:latest
    command: -H unix:///var/run/docker.sock
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    deploy:
      mode: global
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=true
        - traefik.http.routers.portainer-secure.entrypoints=websecure
        - traefik.http.routers.portainer-secure.rule=Host(`admin.$BASE_DOMAIN_REPLACE`)
        - traefik.http.routers.portainer-secure.service=portainer
        - traefik.http.routers.portainer-secure.tls.certresolver=letsencrypt
        - traefik.http.services.portainer.loadbalancer.server.port=9000
    networks:
      - frontend

volumes:
  portainer_data:
    driver: local
    driver_opts:
      type: none
      device: $DOCKER_DIR/portainer/data
      o: bind

networks:
  frontend:
    external: true
PORTAINER_EOF
            ;;
        redis)
            cat > "$local_path" << 'REDIS_EOF'
version: '3.8'

services:
  redis:
    image: redis:7.2-alpine
    container_name: redis-server
    # Escapar $ para que la variable se pase como string a Redis
    command: redis-server --requirepass "$COMMON_PASSWORD_REPLACE" 
    environment:
      - REDIS_PASSWORD=$COMMON_PASSWORD_REPLACE 
    volumes:
      - redis_data:/data
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=false
    networks:
      - backend

volumes:
  redis_data:
    driver: local
    driver_opts:
      type: none
      device: $DOCKER_DIR/redis/data
      o: bind

networks:
  backend:
    external: true
REDIS_EOF
            ;;
        postgres)
            cat > "$local_path" << 'POSTGRES_EOF'
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD_REPLACE
      - POSTGRES_DB=main_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels:
        - traefik.enable=false
    networks:
      - backend

volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      device: $DOCKER_DIR/postgres/data
      o: bind

networks:
  backend:
    external: true
POSTGRES_EOF
            ;;
        n8n)
            cat > "$local_path" << 'N8N_EOF'
version: '3.8'

services:
  n8n:
    image: n8n.io/n8n:latest
    environment:
      - N8N_HOST=n8.$BASE_DOMAIN_REPLACE
      - N8N_PORT=5678
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=$COMMON_PASSWORD_REPLACE
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_DATABASE=n8n_db
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD_REPLACE
      - GENERIC_TIMEZONE=America/Mexico_City
      - N8N_ENCRYPTION_KEY=$SECRET_KEY_REPLACE
    volumes:
      - n8n_data:/home/node/.n8n
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      labels
