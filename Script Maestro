#!/usr/bin/env bash

# =================================================================================
# INSTALADOR DOCKER SWARM STANDALONE (V5.3.0-SEC - CON HERRAMIENTAS DE SEGURIDAD)
# Adaptado para incluir UFW, Fail2Ban, RKHunter y CHKRootkit.
# =================================================================================

SCRIPT_VERSION="5.3.0-SEC-VERBOSE"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# URLs de stacks (ejemplos)
declare -gA STACK_URLS=(
Â  Â  [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
Â  Â  [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
Â  Â  [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
Â  Â  [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
Â  Â  [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
Â  Â  [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
Â  Â  [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=()Â 

COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

declare -gA INSTALLED_COMPONENTS=(
Â  Â  [dependencies]=false
Â  Â  [security]=false # Agregado para seguimiento de seguridad
Â  Â  [networks]=false
)

# ----------------------------------------------------
# Funciones de Control y EjecuciÃ³n
# ----------------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); }
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# FunciÃ³n de limpieza (ROBUSTA V4.9 + AutodestrucciÃ³n)
cleanup() {
Â  Â  local exit_code=$1
Â  Â  local delete_stacks=${2:-false}
Â  Â Â 
Â  Â  echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
Â  Â Â 
Â  Â  if [ $exit_code -ne 0 ]; then
Â  Â  Â  Â  show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..."
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Eliminar stacks y volumen de inicializaciÃ³n de Chatwoot
Â  Â  Â  Â  for tool_name in "${SELECTED_TOOLS[@]}"; do docker stack rm "$tool_name" 2>/dev/null; done
Â  Â  Â  Â  docker stack rm chatwoot-init 2>/dev/null
Â  Â  Â  Â  sleep 5
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Intentar remover el volumen temporal de Chatwoot en caso de fallo (FIX V4.9)
Â  Â  Â  Â  docker volume rm chatwoot_postgres 2>/dev/null
Â  Â  Â  Â Â 
Â  Â  Â  Â  echo -e "${RED}[ERROR]${NC} Error detectado durante la instalaciÃ³n. Limpiando archivos temporales..."
Â  Â  Â  Â  if [ ${#TEMP_FILES[@]} -gt 0 ]; then
Â  Â  Â  Â  Â  Â  for file in "${TEMP_FILES[@]}"; do if [ -f "$file" ]; then rm -f "$file"; fi; done
Â  Â  Â  Â  fi
Â  Â  fi
Â  Â Â 
Â  Â  # Si se solicita (en Ã©xito), eliminar archivos de despliegue y autodestrucciÃ³n
Â  Â  if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
Â  Â  Â  Â  for tool_name in "${SELECTED_TOOLS[@]}"; do
Â  Â  Â  Â  Â  Â  local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml"
Â  Â  Â  Â  Â  Â  if [ -f "$deploy_file" ]; then rm -f "$deploy_file"; fi
Â  Â  Â  Â  done
Â  Â  Â  Â Â 
Â  Â  Â  Â  # LÃ³gica de autodestrucciÃ³n
Â  Â  Â  Â  local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
Â  Â  Â  Â  cat > "$self_destruct_script" << EOF_SD
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then sudo rm -f "$SCRIPT_PATH"; fi
rm -f "\$0"
EOF_SD
Â  Â  Â  Â  chmod +x "$self_destruct_script"
Â  Â  Â  Â  nohup "$self_destruct_script" >/dev/null 2>&1 &
Â  Â  fi
Â  Â Â 
Â  Â  echo -e "${BLUE}[INFO]${NC} Limpieza completada"
Â  Â Â 
Â  Â  if [ $exit_code -ne 0 ]; then
Â  Â  Â  Â  echo -e "${RED}[ERROR]${NC} La instalaciÃ³n ha fallado. Revise los logs para mÃ¡s informaciÃ³n."
Â  Â  else
Â  Â  Â  Â  echo -e "${GREEN}[SUCCESS]${NC} InstalaciÃ³n completada exitosamente"
Â  Â  fi
Â  Â Â 
Â  Â  exit $exit_code
}

# Configurar trampas para seÃ±ales para limpiar antes de salir
trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false' ERR

# FUNCIÃ“N run_command (Modificada para Verbose): Ejecuta comandos mostrando TODO el output
run_command() {
Â  Â  local cmd=$1
Â  Â  local msg=$2
Â  Â Â 
Â  Â  show_message "$msg"
Â  Â  echo -e "${YELLOW}Ejecutando: ${cmd}${NC}"
Â  Â  echo "--------------------------- INICIO OUTPUT ---------------------------"

Â  Â  # Ejecuta el comando directamente (sin subshell ni archivos temporales)
Â  Â  if ! eval "$cmd"; then
Â  Â  Â  Â  local exit_status=$?
Â  Â  Â  Â  echo "--------------------------- FIN OUTPUT ----------------------------"
Â  Â  Â  Â  show_error "Comando fallÃ³ con estado $exit_status."
Â  Â  Â  Â  show_error "Comando: ${cmd}"
Â  Â  Â  Â  cleanup 1 # Llama a cleanup y sale con el estado de error
Â  Â  fi
Â  Â Â 
Â  Â  echo "--------------------------- FIN OUTPUT ----------------------------"
Â  Â  show_success "Comando completado exitosamente."
Â  Â  return 0
}


# FunciÃ³n de descarga (CURL DIRECTO - Muestra la barra de progreso)
download_stack_content() {
Â  Â  local tool_name=$1
Â  Â  local local_path=$2
Â  Â  local download_url=${STACK_URLS[$tool_name]}

Â  Â  if [ -z "$download_url" ]; then
Â  Â  Â  Â  show_error "ERROR: URL de descarga no definida para $tool_name."
Â  Â  Â  Â  cleanup 1
Â  Â  fi
Â  Â Â 
Â  Â  show_message "Descargando stack de $tool_name desde: $download_url"

Â  Â  # curl --progress-bar garantiza que se vea el progreso
Â  Â  run_command "curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o \"$local_path\" \"$download_url\"" "Descargando archivo stack para $tool_name..."
Â  Â Â 
Â  Â  if [ ! -s "$local_path" ]; then
Â  Â  Â  Â  show_error "El archivo descargado estÃ¡ vacÃ­o. URL incorrecta o inaccesible."
Â  Â  Â  Â  rm -f "$local_path"
Â  Â  Â  Â  cleanup 1
Â  Â  fi

Â  Â  show_success "Archivo $tool_name-stack.yml descargado y verificado."
Â  Â  register_temp_file "$local_path"
}


# ----------------------------------------------------
# Funciones de Infraestructura y Despliegue (Robustez V4.9)
# ----------------------------------------------------

# MODIFICADA: Ahora muestra el estado del servicio cada 10s (CERO SPINNER)
wait_for_service() {
Â  Â  local stack_name=$1
Â  Â  local max_wait=180
Â  Â  local wait_time=0
Â  Â  show_message "Verificando el estado de salud del stack '$stack_name'. MÃ¡ximo de espera: $max_wait segundos."

Â  Â  while [ $wait_time -lt $max_wait ]; do
Â  Â  Â  Â Â 
Â  Â  Â  Â  echo -e "${YELLOW}--- Estatus de Servicio ($stack_name) - Tareas y RÃ©plicas: $wait_time/$max_wait segundos ---${NC}"
Â  Â  Â  Â  # Muestra el estado detallado de las tareas del servicio
Â  Â  Â  Â  docker service ps "$stack_name"
Â  Â  Â  Â  echo -e "${YELLOW}-----------------------------------------------------------------------------------${NC}"

Â  Â  Â  Â  local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1)
Â  Â  Â  Â Â 
Â  Â  Â  Â  if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; then
Â  Â  Â  Â  Â  Â  local running=$(echo "$status" | cut -d '/' -f 1)
Â  Â  Â  Â  Â  Â  local desired=$(echo "$status" | cut -d '/' -f 2)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ]; then
Â  Â  Â  Â  Â  Â  Â  Â  show_success "Servicio '$stack_name' listo ($running/$desired rÃ©plicas)."
Â  Â  Â  Â  Â  Â  Â  Â  return 0
Â  Â  Â  Â  Â  Â  fi
Â  Â  Â  Â  fi
Â  Â  Â  Â Â 
Â  Â  Â  Â  local failed_tasks=$(docker service ps "$stack_name" --filter "desired-state=running" --filter "state=failed" --format "{{.ID}}" 2>/dev/null)
Â  Â  Â  Â  if [ -n "$failed_tasks" ]; then
Â  Â  Â  Â  Â  Â  show_error "El servicio '$stack_name' tiene tareas fallidas. Revisando logs para diagnÃ³stico..."
Â  Â  Â  Â  Â  Â  docker service ps "$stack_name" --no-trunc
Â  Â  Â  Â  Â  Â  if [ "$stack_name" == "redis" ]; then
Â  Â  Â  Â  Â  Â  Â  Â  show_message "Extrayendo logs del servicio redis_redis-server fallido..."
Â  Â  Â  Â  Â  Â  Â  Â  docker service logs "${stack_name}_redis-server" 2>/dev/null
Â  Â  Â  Â  Â  Â  fi
Â  Â  Â  Â  Â  Â  return 1
Â  Â  Â  Â  fi
Â  Â  Â  Â Â 
Â  Â  Â  Â  sleep 10
Â  Â  Â  Â  wait_time=$((wait_time + 10))
Â  Â  done

Â  Â  show_error "El servicio '$stack_name' no se estabilizÃ³ despuÃ©s de $max_wait segundos. Revise los logs."
Â  Â  docker service ps "$stack_name" --no-trunc
Â  Â  return 1
}

# ----------------------------------------------------
# Funciones de Flujo (Utilizan el nuevo run_command)
# ----------------------------------------------------

install_dependencies() {
Â  Â  show_message "Verificando e instalando dependencias..."
Â  Â  run_command "apt-get update" "Actualizando repositorios..."
Â  Â  run_command "apt-get install -y ca-certificates curl git wget" "Instalando utilidades (git, curl, wget)..."
Â  Â  if ! command -v docker &> /dev/null; then
Â  Â  Â  Â  show_message "Instalando Docker..."
Â  Â  Â  Â  run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..."
Â  Â  Â  Â  run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null" "AÃ±adiendo repositorio de Docker..."
Â  Â  Â  Â  run_command "apt-get update" "Actualizando repositorios nuevamente..."
Â  Â  Â  Â  run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
Â  Â  Â  Â  run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..."
Â  Â  fi
Â  Â  INSTALLED_COMPONENTS["dependencies"]=true
}

# --- FUNCIÃ“N AGREGADA DE SEGURIDAD (UFW, FAIL2BAN, RKHUNTER, CHKROOTKIT) ---
configure_security_tools() {
    show_message "ðŸ›¡ï¸ Configurando herramientas de seguridad: UFW, Fail2Ban, RKHunter y CHKRootkit..."

    # 1. InstalaciÃ³n de paquetes de seguridad
    run_command "apt-get install -y ufw fail2ban rkhunter chkrootkit" "Instalando UFW, Fail2Ban, RKHunter y CHKRootkit..."
    
    # 2. ConfiguraciÃ³n de UFW (Firewall)
    show_message "Configurando UFW (Firewall)..."
    
    # Permitir puertos necesarios para Docker Swarm y la web (Traefik)
    run_command "ufw allow 22/tcp comment 'Allow SSH'" "Permitiendo el puerto SSH (22/tcp)..."
    run_command "ufw allow 80/tcp comment 'Allow HTTP (Traefik)'" "Permitiendo el puerto HTTP (80/tcp)..."
    run_command "ufw allow 443/tcp comment 'Allow HTTPS (Traefik)'" "Permitiendo el puerto HTTPS (443/tcp)..."

    # Permisos especÃ­ficos para Docker Swarm (opcionales si se usa UFW para la interfaz principal)
    # run_command "ufw allow 2377/tcp comment 'Docker Swarm Management'" "Permitiendo puerto 2377 para Swarm Management..."
    # run_command "ufw allow 7946 comment 'Docker Swarm Communication'" "Permitiendo puertos 7946 para Swarm Comms..."
    # run_command "ufw allow 4789/udp comment 'Docker Swarm Overlay Network'" "Permitiendo puerto 4789/udp para Overlay Network..."

    # PolÃ­tica por defecto: Denegar entrante, permitir saliente
    run_command "ufw default deny incoming && ufw default allow outgoing" "Estableciendo polÃ­ticas por defecto (Denegar Entrante, Permitir Saliente)..."
    
    # Habilitar UFW (la tuberÃ­a 'echo y' automatiza la confirmaciÃ³n de la desconexiÃ³n SSH)
    show_message "Habilitando UFW. Se permite SSH, HTTP y HTTPS."
    run_command "echo 'y' | ufw enable" "Habilitando el Firewall (UFW)..."

    # 3. ConfiguraciÃ³n de Fail2Ban (AutomÃ¡tico)
    run_command "systemctl enable fail2ban && systemctl start fail2ban" "Asegurando que Fail2Ban estÃ© corriendo y habilitado..."
    show_success "Fail2Ban configurado y protegiendo SSH."
    
    # 4. ConfiguraciÃ³n de RKHunter y CHKRootkit
    run_command "rkhunter --update" "Actualizando base de datos de RKHunter..."
    run_command "rkhunter --propupdate" "Actualizando la base de datos de propiedades de archivos de RKHunter (Post-instalaciÃ³n)."
    show_success "RKHunter y CHKRootkit instalados. EjecÃºtelos periÃ³dicamente (ej: 'rkhunter -c')."
    
    INSTALLED_COMPONENTS["security"]=true
}
# ----------------------------------------------------------------------------------


initialize_docker_swarm() {
Â  Â  show_message "Verificando estado de Docker Swarm..."
Â  Â  if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
Â  Â  Â  Â  run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
Â  Â  else
Â  Â  Â  Â  show_message "Docker Swarm ya estÃ¡ activo"
Â  Â  fi
}

create_docker_networks() {
Â  Â  show_message "Creando redes Docker para Swarm..."
Â  Â  if ! docker network ls 2>/dev/null | grep -q "frontend"; then
Â  Â  Â  Â  run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
Â  Â  fi
Â  Â  if ! docker network ls 2>/dev/null | grep -q "backend"; then
Â  Â  Â  Â  run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
Â  Â  fi
Â  Â  INSTALLED_COMPONENTS["networks"]=true
}

initialize_chatwoot_database() {
Â  Â  show_message "Inicializando base de datos de Chatwoot (Proceso avanzado, FIX garantizado V4.9)..."
Â  Â  local container_id=$(docker ps -q --filter "name=redis_redis-server")
Â  Â  if [ -z "$container_id" ]; then show_error "Redis no estÃ¡ desplegado."; return 1; fi
Â  Â  run_command "docker volume create --driver local --opt type=none --opt device=$DOCKER_DIR/chatwoot/postgres_data --opt o=bind chatwoot_postgres" "Creando volumen temporal para la inicializaciÃ³n de Chatwoot DB..."
Â  Â  local init_stack_file="/tmp/chatwoot-init-stack.yml"
Â  Â Â 
Â  Â  # CreaciÃ³n del stack temporal (sin cambios de lÃ³gica)
Â  Â  cat > "$init_stack_file" << EOF_INIT
version: '3.8'
services:
Â  chatwoot-postgres:
Â  Â  image: pgvector/pgvector:pg16
Â  Â  environment:
Â  Â  Â  - POSTGRES_DB=chatwoot
Â  Â  Â  - POSTGRES_USER=postgres
Â  Â  Â  - POSTGRES_PASSWORD=$COMMON_PASSWORD
Â  Â  Â  - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
Â  Â  volumes: [chatwoot_postgres:/var/lib/postgresql/data]
Â  Â  deploy: {replicas: 1, placement: {constraints: [node.role == manager]}}
Â  Â  networks: [backend]
Â  chatwoot-init:
Â  Â  image: chatwoot/chatwoot:latest
Â  Â  command: ["/bin/sh", "-c", "sleep 15 && bundle exec rails db:chatwoot_prepare"]
Â  Â  environment:
Â  Â  Â  - POSTGRES_HOST=chatwoot-postgres
Â  Â  Â  - POSTGRES_PORT=5432
Â  Â  Â  - POSTGRES_DATABASE=chatwoot
Â  Â  Â  - POSTGRES_USERNAME=postgres
Â  Â  Â  - POSTGRES_PASSWORD=$COMMON_PASSWORD
Â  Â  Â  - REDIS_URL=redis://redis-server:6379/4
Â  Â  Â  - SECRET_KEY_BASE=$SECRET_KEY
Â  Â  Â  - RAILS_ENV=production
Â  Â  Â  - NODE_ENV=production
Â  Â  networks: [backend]
Â  Â  depends_on: [chatwoot-postgres]
Â  Â  deploy: {restart_policy: {condition: none}, placement: {constraints: [node.role == manager]}}
networks:
Â  backend: {external: true}
volumes:
Â  chatwoot_postgres: {external: true}
EOF_INIT
Â  Â  register_temp_file "$init_stack_file"
Â  Â  run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack de inicializaciÃ³n temporal..."
Â  Â  show_message "Esperando a que el servicio de inicializaciÃ³n de Chatwoot complete su tarea..."
Â  Â Â 
Â  Â  # Bucle de espera sin spinner
Â  Â  local init_complete=false; local max_wait=900; local wait_time=0
Â  Â  while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
Â  Â  Â  Â  local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
Â  Â  Â  Â  if echo "$service_status" | grep -q "Complete"; then init_complete=true; show_success "InicializaciÃ³n completada."; break
Â  Â  Â  Â  elif echo "$service_status" | grep -q "Failed" || echo "$service_status" | grep -q "Shutdown"; then
Â  Â  Â  Â  Â  Â  show_error "La inicializaciÃ³n de la base de datos fallÃ³."
Â  Â  Â  Â  Â  Â  show_message "Extrayendo logs del servicio fallido chatwoot-init_chatwoot-init..."
Â  Â  Â  Â  Â  Â  docker service logs chatwoot-init_chatwoot-init --tail 50
Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  fi
Â  Â  Â  Â  sleep 10; wait_time=$((wait_time + 10))
Â  Â  Â  Â  show_message "Estado actual del inicializador: $service_status (Esperando $wait_time de $max_wait segundos)"
Â  Â  done
Â  Â  run_command "docker stack rm chatwoot-init" "Limpiando stack temporal de inicializaciÃ³n..."
Â  Â  sleep 10
Â  Â  show_message "Intentando eliminar el volumen temporal 'chatwoot_postgres' de forma robusta..."
Â  Â  local volume_removed=false; local attempts=0; local max_attempts=6
Â  Â  while [ "$volume_removed" = false ] && [ $attempts -lt $max_attempts ]; do
Â  Â  Â  Â  if docker volume rm chatwoot_postgres 2>/dev/null; then volume_removed=true; show_success "Volumen temporal eliminado."; break
Â  Â  Â  Â  else show_warning "Volumen 'chatwoot_postgres' aÃºn en uso. Reintentando en 5 segundos (Intento $((attempts + 1)) de $max_attempts)..."; sleep 5; attempts=$((attempts + 1)); fi
Â  Â  done
Â  Â  if [ "$init_complete" = true ]; then return 0; else return 1; fi
}

install_docker_tool() {
Â  Â  local tool_name=$1
Â  Â  local default_subdomain=$2
Â  Â  show_message "Configurando $tool_name..."
Â  Â  local tool_dir="$DOCKER_DIR/$tool_name"
Â  Â  mkdir -p $tool_dir; cd $tool_dir || { show_error "No se pudo acceder a $tool_dir"; cleanup 1; }
Â  Â  local tool_index=-1
Â  Â  for i in "${!AVAILABLE_TOOLS[@]}"; do if [ "${AVAILABLE_TOOLS[$i]}" = "$tool_name" ]; then tool_index=$i; break; fi; done
Â  Â  read -p "Ingrese el subdominio para $tool_name [$default_subdomain]: " SUBDOMAIN
Â  Â  SUBDOMAIN=${SUBDOMAIN:-$default_subdomain}
Â  Â  CUSTOM_SUBDOMAINS[$tool_index]=$SUBDOMAIN
Â  Â  local subdomain_file="$tool_dir/.subdomain"
Â  Â  echo "$SUBDOMAIN" > "$subdomain_file"; register_temp_file "$subdomain_file"
Â  Â  local stack_file="$tool_dir/$tool_name-stack.yml"
Â  Â  download_stack_content "$tool_name" "$stack_file"
Â  Â  local deploy_file="$tool_dir/$tool_name-deploy.yml"
Â  Â  cp "$stack_file" "$deploy_file"; register_temp_file "$deploy_file"
Â  Â  show_message "Aplicando sanitizaciÃ³n de variables en el stack de despliegue..."
Â  Â  sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$deploy_file"
Â  Â  sed -i "s|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"
Â  Â  sed -i "s|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"
Â  Â  if [ "$tool_name" == "redis" ]; then
Â  Â  Â  Â  show_message "Aplicando **correcciÃ³n crÃ­tica de configuraciÃ³n V4.7: Eliminando comando de Redis**."
Â  Â  Â  Â  sed -i '/command:/d' "$deploy_file"; show_success "CorrecciÃ³n de Redis V4.7 aplicada."
Â  Â  fi
Â  Â  if [ "$tool_name" == "postgres" ]; then
Â  Â  Â  Â  show_message "Aplicando correcciÃ³n de variable de entorno para PostgreSQL."
Â  Â  Â  Â  sed -i "s/POSTGRES_PASSWORD: .*/POSTGRES_PASSWORD: \$COMMON_PASSWORD/g" "$deploy_file"; show_success "CorrecciÃ³n de PostgreSQL aplicada."
Â  Â  fi
Â  Â  local volume_paths=$(grep -oP "device: \K/[^\s]+" "$deploy_file" | sort | uniq)
Â  Â  for path in $volume_paths; do run_command "mkdir -p \"$path\"" "Creando directorio $path..."; done
Â  Â  if [ "$tool_name" = "chatwoot" ]; then
Â  Â  Â  Â  show_message "Chatwoot detectado - Ejecutando inicializaciÃ³n de base de datos..."
Â  Â  Â  Â  if ! docker service ls | grep -q "redis_redis"; then show_error "Redis no estÃ¡ desplegado."; cleanup 1; fi
Â  Â  Â  Â  if initialize_chatwoot_database; then show_success "Base de datos de Chatwoot inicializada."; else show_error "Error crÃ­tico al inicializar DB de Chatwoot."; cleanup 1; fi
Â  Â  Â  Â  run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name (Stack Final)..."
Â  Â  else
Â  Â  Â  Â  run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name..."
Â  Â  fi
Â  Â  if [ "$tool_name" = "redis" ] || [ "$tool_name" = "postgres" ]; then
Â  Â  Â  Â  if ! wait_for_service "$tool_name"; then show_error "El stack $tool_name no se estabilizÃ³. **FALLO CRÃTICO.**"; cleanup 1; fi
Â  Â  fi
Â  Â  show_success "$tool_name instalado correctamente en Docker Swarm"
Â  Â  INSTALLED_COMPONENTS["$tool_name"]=true
Â  Â  cd $DOCKER_DIR || { show_error "No se pudo volver al directorio principal $DOCKER_DIR"; cleanup 1; }
}


# ----------------------------------------------------
# Flujo Principal
# ----------------------------------------------------
main() {
Â  Â  echo -e "\n${GREEN}=======================================================${NC}"
Â  Â  echo -e "${GREEN}Â  ðŸš€ INSTALADOR DOCKER STANDALONE (V5.3.0-SEC) ðŸš€Â  ${NC}"
Â  Â  echo -e "${GREEN}Â  âœ… SEGURIDAD ADICIONAL: UFW, Fail2Ban, RKHunter.Â  Â  Â ${NC}"
Â  Â  echo -e "${GREEN}=======================================================${NC}\n"

Â  Â  if [ "$EUID" -ne 0 ]; then show_error "Este script debe ejecutarse como root."; cleanup 1; exit 1; fi
Â  Â  mkdir -p $DOCKER_DIR; cd $DOCKER_DIR || { show_error "No se pudo acceder a $DOCKER_DIR"; cleanup 1; exit 1; }

Â  Â  show_message "ConfiguraciÃ³n inicial"
Â  Â  read -sp "Ingrese la contraseÃ±a comÃºn para todas las herramientas: " COMMON_PASSWORD
Â  Â  echo
Â  Â  if [ -z "$COMMON_PASSWORD" ]; then show_error "La contraseÃ±a no puede estar vacÃ­a"; cleanup 1; exit 1; fi
Â  Â  read -p "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
Â  Â  if [ -z "$BASE_DOMAIN" ]; then show_error "El dominio no puede estar vacÃ­o"; cleanup 1; exit 1; fi
Â  Â  DEFAULT_SECRET_KEY=$(generate_random_key)
Â  Â  read -p "Ingrese una clave secreta de 32 caracteres (o Enter para usar la generada): " SECRET_KEY
Â  Â  SECRET_KEY=${SECRET_KEY:-$DEFAULT_SECRET_KEY}
Â  Â  if [ ${#SECRET_KEY} -ne 32 ]; then show_warning "Clave proporcionada no tiene 32 caracteres. Usando la generada."; SECRET_KEY=$DEFAULT_SECRET_KEY; fi
Â  Â  show_message "Clave secreta utilizada: $SECRET_KEY"

Â  Â  env_global_file="$DOCKER_DIR/.env.global"
Â  Â  cat > $env_global_file << EOL
COMMON_PASSWORD=$COMMON_PASSWORD
BASE_DOMAIN=$BASE_DOMAIN
SECRET_KEY=$SECRET_KEY
EOL
Â  Â  show_success "Variables globales guardadas en $env_global_file"

Â  Â  # 1. INSTALACIÃ“N DE DEPENDENCIAS
Â  Â  install_dependencies
    
    # 2. CONFIGURACIÃ“N DE SEGURIDAD (Â¡NUEVO!)
    configure_security_tools

Â  Â  # 3. INICIALIZACIÃ“N DE DOCKER Y REDES
Â  Â  initialize_docker_swarm
Â  Â  create_docker_networks

Â  Â  show_message "Instalando servicios en orden de dependencias..."
Â  Â  INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot")
Â  Â Â 
Â  Â  # 4. DESPLIEGUE DE STACKS
Â  Â  for tool_name in "${INSTALL_ORDER[@]}"; do
Â  Â  Â  Â  default_subdomain=""
Â  Â  Â  Â  for j in "${!AVAILABLE_TOOLS[@]}"; do
Â  Â  Â  Â  Â  Â  if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"; break; fi
Â  Â  Â  Â  done
Â  Â  Â  Â  install_docker_tool "$tool_name" "$default_subdomain"
Â  Â  done

Â  Â  echo ""
Â  Â  show_success "ðŸŽ‰ Â¡INSTALACIÃ“N COMPLETADA! ðŸŽ‰"

Â  Â  echo "Accede a tus servicios en los siguientes URLs:"
Â  Â  for i in "${!SELECTED_TOOLS[@]}"; do
Â  Â  Â  Â  tool_name="${SELECTED_TOOLS[$i]}"
Â  Â  Â  Â  tool_index=-1
Â  Â  Â  Â  for j in "${!AVAILABLE_TOOLS[@]}"; do if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then tool_index=$j; break; fi; done
Â  Â  Â  Â  if [ $tool_index -ge 0 ]; then
Â  Â  Â  Â  Â  Â  subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
Â  Â  Â  Â  Â  Â  subdomain=""
Â  Â  Â  Â  Â  Â  if [ -f "$subdomain_file" ]; then subdomain=$(cat "$subdomain_file"); else subdomain="${CUSTOM_SUBDOMAINS[$tool_index]:-${DEFAULT_SUBDOMAINS[$tool_index]}}"; fi
Â  Â  Â  Â  Â  Â  echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN"
Â  Â  Â  Â  fi
Â  Â  done
Â  Â Â 
Â  Â  echo ""
Â  Â  echo "InformaciÃ³n de credenciales:"
Â  Â  echo "- ContraseÃ±a comÃºn: $COMMON_PASSWORD"
Â  Â  echo "- Clave secreta: $SECRET_KEY"
Â  Â  echo "Esta informaciÃ³n se ha guardado en: $DOCKER_DIR/.env.global"
Â  Â  echo "==========================================="

Â  Â  cleanup 0 true
}

# Ejecutar funciÃ³n principal
main
