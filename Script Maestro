#!/usr/bin/env bash
# =================================================================================
# UNIFIED INSTALLER SCRIPT (v3.0.6 - FIX CHATWOOT TIMEOUT)
# Aumenta el tiempo de espera de la inicialización de Chatwoot a 15 minutos.
# =================================================================================

SCRIPT_VERSION="3.0.6-TIMEOUT-FIX"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# Configuracion de URLs para descarga de Stacks
# ¡Descarga directa desde GitHub!
# -----------------------------------------------
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)


declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# Lista de herramientas disponibles y subdominios predeterminados
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=()
CUSTOM_SUBDOMAINS=()


# Variables globales para credenciales
BASE_DOMAIN=""
COMMON_PASSWORD=""
SECRET_KEY=""


# Funciones de utilidad para mensajes
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# -----------------------------------------------
# FUNCIONES DE EJECUCIÓN CON VISIBILIDAD (SPINNER)
# -----------------------------------------------

# Función para animación de espera
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Función para ejecutar comandos mostrando animación de espera
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    
    local temp_output=$(mktemp)
    
    # Ejecutar en segundo plano, imprimiendo salida al mismo tiempo
    (eval "$cmd" 2>&1 | tee "$temp_output") &
    local cmd_pid=$!
    
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    
    local output=$(cat "$temp_output")
    rm -f "$temp_output"
    
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló. Revise el error a continuación."
        show_error "Salida/Error del comando: $output"
        cleanup 1
        exit $exit_status
    fi
    
    return $exit_status
}

# -----------------------------------------------
# FUNCIONES DE UTILIDAD
# -----------------------------------------------

# Función de limpieza (incluye autodestrucción del script)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado. Limpiando archivos temporales..."
        
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
        done
    fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF

        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM ERR

# Función para registrar un archivo temporal
register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
}


# Función para descargar archivos
download_stack_file() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "URL de descarga no encontrada para la herramienta: $tool_name"
        cleanup 1
        exit 1
    fi
    
    show_message "Descargando stack '$tool_name' desde GitHub..."
    
    if ! curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o "$local_path" "$download_url"; then
        show_error "Error al descargar el archivo stack para $tool_name desde $download_url"
        cleanup 1
        exit 1
    fi
    
    register_temp_file "$local_path"
    show_success "Archivo stack para $tool_name descargado correctamente"
    return 0
}

# Función para generar clave aleatoria de 32 caracteres
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# Función para configurar tamaño de los logs de Docker
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"
    show_message "Configurando límites de logs en Docker..."
    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF
    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuración..."
}

# Función para configurar rkhunter
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"
    show_message "Configurando RKHunter..."
    run_command "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                  sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
                  sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                "Aplicando configuración de RKHunter..."
}

# Instalar dependencias
install_dependencies() {
    show_message "Verificando e instalando dependencias (Docker, curl, git)..."
    run_command "apt-get update" "Actualizando lista de paquetes del sistema..."

    if ! command -v docker &> /dev/null; then
        show_message "Docker no encontrado. Instalando..."
        run_command "apt-get install -y ca-certificates curl" "Instalando certificados y curl..."
        run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Añadiendo clave GPG de Docker..."
        
        echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        
        run_command "apt-get update" "Actualizando paquetes post-repositorio Docker..."
        run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando componentes principales de Docker..."
        run_command "systemctl enable docker && systemctl start docker" "Habilitando y arrancando servicio Docker..."
        configure_docker_logs
        show_success "Docker y dependencias instaladas."
    else
        show_success "Docker ya está instalado. Omitiendo la instalación de dependencias."
    fi
    
    run_command "apt-get install -y git curl wget" "Instalando utilidades del sistema (git, wget)..."
}

# Inicializar Docker Swarm
initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
        if [ $? -eq 0 ]; then
            show_success "Docker Swarm inicializado correctamente"
        else
            show_error "Error al inicializar Docker Swarm"
            cleanup 1
            exit 1
        fi
    else
        show_message "Docker Swarm ya está activo"
    fi

    INSTALLED_COMPONENTS["dependencies"]=true
}

# Instalar herramientas de seguridad
install_server_tools() {
    show_message "Instalando herramientas de seguridad: UFW, Fail2Ban, RKHunter, CHKRootkit..."
    
    show_message "Instalando Fail2Ban..."
    run_command "apt-get install -y fail2ban && systemctl enable fail2ban && systemctl start fail2ban" "Configurando Fail2Ban..."
    
    show_message "Instalando RKHunter..."
    echo "postfix postfix/main_mailer_type select No configuration" | debconf-set-selections
    run_command "apt-get install -y rkhunter" "Descargando RKHunter..."
    configure_rkhunter
    run_command "rkhunter --update" "Actualizando base de datos de RKHunter..."
    run_command "rkhunter --propupd" "Actualizando propiedades de RKHunter..."
    
    show_message "Instalando CHKRootkit..."
    run_command "apt-get install -y chkrootkit" "Descargando CHKRootkit..."

    show_message "Configurando UFW Firewall (Permite 22, 80, 443)..."
    run_command "apt-get install -y ufw" "Instalando UFW..."
    run_command "ufw allow ssh && ufw allow http && ufw allow https && echo 'y' | ufw enable" "Activando UFW y reglas básicas..."
    
    show_success "Herramientas de seguridad instaladas correctamente"
    INSTALLED_COMPONENTS["security"]=true
}

# Crear redes de Docker para Swarm
create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
        show_success "Red 'frontend' creada"
    else
        show_warning "La red 'frontend' ya existe"
    fi
    
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
        show_success "Red 'backend' creada"
    else
        show_warning "La red 'backend' ya existe"
    fi
    INSTALLED_COMPONENTS["networks"]=true
}

# Función para crear directorios para volúmenes
create_volume_directories() {
    local stack_file=$1
    local tool_name=$2
    
    show_message "Creando directorios para volúmenes de $tool_name..."
   
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)

    if [ -z "$volume_paths" ]; then
        show_message "No se encontraron rutas de volúmenes para $tool_name"
        return
    fi

    for path in $volume_paths; do
        run_command "mkdir -p \"$path\"" "Creando directorio $path..."
        if [ $? -ne 0 ]; then
             show_error "Error al crear el directorio $path"
             cleanup 1
             exit 1
        fi
    done
}


# Función para inicializar la base de datos de Chatwoot
initialize_chatwoot_database() {
    local tool_name="chatwoot"
    local subdomain=$1
    
    show_message "Inicializando base de datos de Chatwoot..."
    
    local init_stack_file="$DOCKER_DIR/$tool_name/$tool_name-init-stack.yml"
    cat > "$init_stack_file" <<EOF
version: '3.7'
services:
  db-init:
    image: chatwoot/chatwoot:latest
    command: bundle exec rails db:chatwoot_setup
    environment:
      - RAILS_ENV=production
      - POSTGRES_HOST=postgres_postgres-server
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - POSTGRES_DATABASE=chatwoot_db
      - SECRET_KEY_BASE=$SECRET_KEY
      - REDIS_URL=redis://redis_redis-server:6379/1
    networks:
      - backend
    deploy:
      mode: replicated
      replicas: 1
      restart_policy:
        condition: "none"
networks:
  backend:
    external: true
EOF
    register_temp_file "$init_stack_file"

    run_command "docker stack deploy -c $init_stack_file ${tool_name}-init" "Desplegando stack de inicialización de base de datos..."

    show_message "Esperando a que la inicialización de la base de datos termine (¡Aumentado a 15 minutos!)..."
    local init_service_id="${tool_name}-init_db-init"
    local init_task_status=""
    local max_wait=900 # Aumentado a 15 minutos (900 segundos)

    for i in $(seq 1 $max_wait); do
        init_task_status=$(docker service ps -f "desired-state=shutdown" -f "name=${init_service_id}" --format "{{.CurrentState}}" ${tool_name}-init 2>/dev/null | head -n 1)
        
        if [[ "$init_task_status" == *"Shutdown"* ]]; then
            show_success "Inicialización de base de datos completada exitosamente"
            break
        fi
        if [ $i -eq $max_wait ]; then
            show_error "Timeout: El servicio de inicialización de Chatwoot no finalizó después de 15 minutos. Revise los logs del servicio."
            run_command "docker stack rm ${tool_name}-init" "Limpiando stack de inicialización fallido..."
            cleanup 1
            exit 1
        fi
        sleep 1
    done

    run_command "docker stack rm ${tool_name}-init" "Limpiando stack de inicialización..."
    
    show_success "Base de datos de Chatwoot inicializada correctamente"
}


# Función para sanear y desplegar cada herramienta
install_tool() {
    local tool_name=$1
    local subdomain=$2
    local stack_dir="$DOCKER_DIR/$tool_name"
    local stack_file="$stack_dir/$tool_name-stack.yml"
    
    show_message "Preparando instalación de $tool_name con subdominio: $subdomain.$BASE_DOMAIN"

    # Verificar si el stack ya existe y si es el caso, saltar
    if docker stack ls 2>/dev/null | grep -q "$tool_name"; then
        show_warning "El stack '$tool_name' ya está desplegado. Omitiendo la descarga e instalación."
        echo "$subdomain" > "$DOCKER_DIR/$tool_name/.subdomain" # Asegurar que el subdominio esté guardado
        return 0
    fi
    
    mkdir -p "$stack_dir"
    download_stack_file "$tool_name" "$stack_file"

    create_volume_directories "$stack_file" "$tool_name"

    local full_domain="$subdomain.$BASE_DOMAIN"

    show_message "Aplicando sanitización de variables..."
    
    # 1. Reemplazar variables de entorno clave
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$stack_file"
    sed -i "s|N8N_ENCRYPTION_KEY=.*|N8N_ENCRYPTION_KEY=$SECRET_KEY|g" "$stack_file"
    sed -i "s|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    
    # 2. Reemplazar subdominio y dominio (URLs y Reglas Traefik)
    sed -i "s/REPLACE_SUBDOMAIN.REPLACE_DOMAIN/$full_domain/g" "$stack_file"
    sed -i "s/REPLACE_DOMAIN/$BASE_DOMAIN/g" "$stack_file"
    sed -i "s/N8N_HOST=.*$/N8N_HOST=$full_domain/g" "$stack_file"
    sed -i "s|N8N_EDITOR_BASE_URL=.*|N8N_EDITOR_BASE_URL=https://$full_domain|g" "$stack_file"
    sed -i "s/HOST=.*$/HOST=$full_domain/g" "$stack_file" # EvoAPI

    # Manejo de casos especiales (CORRECCIONES DE FALLOS)
    if [ "$tool_name" == "redis" ]; then
        show_message "Aplicando corrección de sintaxis y contraseña para Redis..."

        sed -i "s/command: redis-server --loglevel warning/command: redis-server --requirepass $COMMON_PASSWORD --loglevel warning/g" "$stack_file"

        sed -i '/image: redislabs\/redisinsight:latest/a\    environment:\n      - REDISINSIGHT_PASSWORD=\$COMMON_PASSWORD\n      - REDIS_PASSWORD=\$COMMON_PASSWORD' "$stack_file"
        
        show_success "Corrección de Redis aplicada."
    fi

    if [ "$tool_name" == "n8n" ]; then
        show_message "Ajustando subdominios de webhook para n8n..."
        sed -i "s/WEBHOOK_URL=https:\/\/webhook\..*$/WEBHOOK_URL=https:\/\/webhook.$full_domain/g" "$stack_file"
        sed -i "s/REPLACE_WEBHOOK_SUBDOMAIN/webhook.$subdomain/g" "$stack_file"
        show_success "Ajuste de n8n aplicado."
    fi
    show_success "Sanitización de $tool_name completada."

    # Desplegar el stack
    run_command "docker stack deploy -c $stack_file $tool_name" "Desplegando $tool_name en Docker Swarm..."
    
    if [ $? -eq 0 ]; then
        show_success "$tool_name instalado correctamente en Docker Swarm"
        echo "$subdomain" > "$DOCKER_DIR/$tool_name/.subdomain"
        return 0
    else
        show_error "Fallo al desplegar $tool_name"
        cleanup 1
        exit 1
    fi
}

# =================================================================
# LÓGICA DE EJECUCIÓN
# =================================================================

get_credentials() {
    show_message "--- CREDENCIALES GLOBALES ---"
    
    # Intentar cargar credenciales previamente guardadas
    if [ -f "$DOCKER_DIR/.env.global" ]; then
        show_message "Credenciales globales encontradas. Usando configuración anterior."
        source "$DOCKER_DIR/.env.global"
        show_success "Dominio: $BASE_DOMAIN | Contraseña: *** | Clave Secreta: ***"
        
        # Necesitamos pedir la confirmación de la contraseña para evitar que sea vacía si el archivo falla
        local temp_password=""
        read -rsp "Confirme la contraseña común para continuar: " temp_password
        echo
        if [ "$temp_password" != "$COMMON_PASSWORD" ]; then
            show_error "Contraseña no coincide. Reiniciando la entrada de credenciales."
            COMMON_PASSWORD=""
            BASE_DOMAIN=""
            SECRET_KEY=""
            get_credentials
            return
        fi
        
    else
        # 1. Contraseña (Mantiene MODO SILENCIOSO por seguridad)
        while [ -z "$COMMON_PASSWORD" ]; do
            read -rsp "Ingrese la contraseña común para todas las herramientas: " COMMON_PASSWORD
            echo
            if [ -z "$COMMON_PASSWORD" ]; then
                show_error "La contraseña no puede estar vacía."
            fi
        done

        # 2. Dominio
        while [ -z "$BASE_DOMAIN" ]; do
            read -rp "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
            if [ -z "$BASE_DOMAIN" ]; then
                show_error "El dominio no puede estar vacío."
            fi
            BASE_DOMAIN=$(echo "$BASE_DOMAIN" | sed 's|^https\?://||')
        done

        # 3. Clave Secreta
        read -rp "Ingrese una clave secreta de 32 caracteres (o presione Enter para generar una): " SECRET_KEY
        if [ -z "$SECRET_KEY" ]; then
            SECRET_KEY=$(generate_random_key)
            show_message "Se utilizará la siguiente clave secreta generada: $SECRET_KEY"
        fi
        
        show_message "Guardando credenciales en $DOCKER_DIR/.env.global..."
        mkdir -p "$DOCKER_DIR"
        echo "BASE_DOMAIN=$BASE_DOMAIN" > "$DOCKER_DIR/.env.global"
        echo "COMMON_PASSWORD=$COMMON_PASSWORD" >> "$DOCKER_DIR/.env.global"
        echo "SECRET_KEY=$SECRET_KEY" >> "$DOCKER_DIR/.env.global"
    fi
}

select_tools_and_subdomains() {
    show_message "--- CONFIGURACIÓN DE HERRAMIENTAS Y SUBDOMINIOS ---"
    
    # Intentar cargar selección anterior
    if [ -f "$DOCKER_DIR/.selection.cfg" ]; then
        show_message "Configuración de herramientas anterior encontrada. Usando la misma selección."
        local saved_data=$(cat "$DOCKER_DIR/.selection.cfg")
        
        # Parsear las herramientas y subdominios
        IFS=$'\n' read -r -d '' -a lines <<< "$saved_data"
        for line in "${lines[@]}"; do
            tool=$(echo "$line" | awk -F'=' '{print $1}')
            subdomain=$(echo "$line" | awk -F'=' '{print $2}')
            SELECTED_TOOLS+=("$tool")
            CUSTOM_SUBDOMAINS+=("$subdomain")
        done

        show_success "Se reanuda la instalación con ${#SELECTED_TOOLS[@]} herramientas."
        return
    fi
    
    # Si no hay configuración previa, pedir al usuario
    SELECTED_TOOLS=()
    CUSTOM_SUBDOMAINS=()

    show_message "Seleccione las herramientas a instalar (deje vacío para instalar TODAS, o ingrese los números separados por espacio, ej: 1 3 5):"
    
    local tool_options=""
    for i in "${!AVAILABLE_TOOLS[@]}"; do
        tool_options+="$((i+1))) ${AVAILABLE_TOOLS[$i]^} (Predeterminado: ${DEFAULT_SUBDOMAINS[$i]}.$BASE_DOMAIN)\n"
    done
    
    echo -e "$tool_options"
    read -rp "Selección [1-7 o dejar vacío para TODO]: " selection

    if [ -z "$selection" ]; then
        SELECTED_TOOLS=("${AVAILABLE_TOOLS[@]}")
        
        show_message "Se instalarán TODAS las herramientas. Configure los subdominios a continuación."
        
        for i in "${!SELECTED_TOOLS[@]}"; do
            local tool_name="${SELECTED_TOOLS[$i]}"
            local default_subdomain="${DEFAULT_SUBDOMAINS[$i]}"
            
            local custom_sub=""
            read -rp "   -> Subdominio para ${tool_name^} (Enter para usar '$default_subdomain'): " custom_sub
            
            if [ -z "$custom_sub" ]; then
                CUSTOM_SUBDOMAINS+=("$default_subdomain")
            else
                CUSTOM_SUBDOMAINS+=("$custom_sub")
            fi
        done
    else
        local selected_indices=($(echo "$selection" | tr ' ' '\n' | sort -n | uniq))
        
        for index in "${selected_indices[@]}"; do
            local array_index=$((index-1))
            if [ "$array_index" -ge 0 ] && [ "$array_index" -lt "${#AVAILABLE_TOOLS[@]}" ]; then
                local tool_name="${AVAILABLE_TOOLS[$array_index]}"
                local default_subdomain="${DEFAULT_SUBDOMAINS[$array_index]}"
                
                SELECTED_TOOLS+=("$tool_name")
                
                local custom_sub=""
                read -rp "   -> Subdominio para ${tool_name^} (Enter para usar '$default_subdomain'): " custom_sub
                
                if [ -z "$custom_sub" ]; then
                    CUSTOM_SUBDOMAINS+=("$default_subdomain")
                else
                    CUSTOM_SUBDOMAINS+=("$custom_sub")
                fi
            else
                show_warning "Opción inválida: $index será ignorada."
            fi
        done
        
        if [ ${#SELECTED_TOOLS[@]} -eq 0 ]; then
            show_error "No se seleccionó ninguna herramienta válida. Saliendo."
            cleanup 1
            exit 1
        fi
    fi

    # Guardar la selección para futuras reanudaciones
    mkdir -p "$DOCKER_DIR"
    local selection_file="$DOCKER_DIR/.selection.cfg"
    rm -f "$selection_file" # Limpiar la anterior
    for i in "${!SELECTED_TOOLS[@]}"; do
        echo "${SELECTED_TOOLS[$i]}=${CUSTOM_SUBDOMAINS[$i]}" >> "$selection_file"
    done

    echo # New line for clean separation
    show_message "¡Listo! Se instalarán las siguientes herramientas en su dominio: ${BASE_DOMAIN}"
    for i in "${!SELECTED_TOOLS[@]}"; do
        echo -e "   - ${SELECTED_TOOLS[$i]^}: https://${CUSTOM_SUBDOMAINS[$i]}.$BASE_DOMAIN"
    done
    echo # New line
}


main_installation_flow() {
    if [ "$EUID" -ne 0 ]; then
        show_error "Por favor, ejecuta este script como root o con sudo."
        exit 1
    fi
    
    get_credentials
    select_tools_and_subdomains 
    
    show_message "Iniciando la instalación automatizada de herramientas Docker..."
    
    # 1. Dependencias y entorno (Se mantienen, pero se saltan si ya están)
    install_dependencies
    initialize_docker_swarm
    create_docker_networks
    install_server_tools 
    
    # 2. Instalación de herramientas (Bucle principal)
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        subdomain="${CUSTOM_SUBDOMAINS[$i]}" 
        
        install_tool "$tool_name" "$subdomain"
        
        # Esperar un tiempo prudente para bases de datos antes de usarlas
        if [ "$tool_name" = "postgres" ] || [ "$tool_name" = "redis" ]; then
            show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
            sleep 15
        fi
        
        # Post-instalación (Solo si el stack se instaló/desplegó, lo cual verifica install_tool)
        if [ "$tool_name" == "chatwoot" ]; then
            # Necesitamos asegurar que el stack de chatwoot esté ejecutándose antes de la inicialización
            if docker stack ps chatwoot 2>/dev/null | grep -q "Running"; then
                 show_message "Esperando 30 segundos para que el stack de Chatwoot se estabilice antes de la inicialización..."
                 sleep 30 
                 initialize_chatwoot_database "$subdomain" 
            else
                 show_warning "El servicio principal de Chatwoot no está en ejecución. Intentando inicialización de todas formas."
                 initialize_chatwoot_database "$subdomain" 
            fi
        fi
    done

    # 3. Mensaje final y limpieza
    finalize_installation
}

finalize_installation() {
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"

        tool_index=-1
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
                tool_index=$j
                break
            fi
        done

        if [ $tool_index -ge 0 ]; then
            subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
            if [ -f "$subdomain_file" ]; then
                subdomain=$(cat "$subdomain_file")
            else
                subdomain="${CUSTOM_SUBDOMAINS[$i]}"
            fi

            echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN"
        fi
    done
    
    echo ""
    echo "Información de credenciales (Guardada en: $DOCKER_DIR/.env.global):"
    echo "- Contraseña común: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""

    cleanup 0 true 
}

# Llamada a la función principal
main_installation_flow
