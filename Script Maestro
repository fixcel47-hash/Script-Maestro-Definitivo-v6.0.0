#!/usr/bin/env bash
# =================================================================================
# INSTALADOR UNIFICADO DOCKER SWARM (v7.1.0 - LIMPIO Y COMPLETO)
# Autor: Adaptado por Gemini AI (Libre de API Token)
# Objetivo: Instalación robusta de stack Docker Swarm (Traefik, Portainer, DBs, n8n, EvoAPI, Chatwoot)
# Muestra el proceso en el terminal con mensajes de [INFO] y [SUCCESS].
# =================================================================================

SCRIPT_VERSION="7.1.0-FINAL"

# --- Colores para mensajes ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Variables Globales ---
DOCKER_DIR="/home/docker"
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30
SECRET_KEY=""
COMMON_PASSWORD=""
BASE_DOMAIN=""

# ------------------------------------------------
# 1. Configuración de Herramientas y URLs
# ------------------------------------------------
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "db" "n8" "api" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot") 

# URLs de los stacks de Docker
declare -gA STACK_URLS=(
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
)

# --- 2. Funciones de Utilidad (Muestran el proceso en el terminal) ---
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
run_command() {
    local command="$1"
    local message="$2"
    show_message "$message"
    
    # Ejecuta el comando y captura el resultado/código de salida
    output=$(eval "$command" 2>&1)
    exit_code=$?
    
    # Muestra el output detallado solo en caso de fallo para un mejor diagnóstico
    if [ $exit_code -ne 0 ]; then
        echo -e "--------------------------- INICIO OUTPUT ---------------------------"
        echo "$output"
        echo -e "--------------------------- FIN OUTPUT ----------------------------"
        show_error "Error al ejecutar el comando. Código: $exit_code"
        return 1
    else
        show_success "Comando completado exitosamente."
        return 0
    fi
}
register_temp_file() {
    TEMP_FILES+=("$1")
}
cleanup() {
    local exit_code=$1
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..."
        for tool in "${AVAILABLE_TOOLS[@]}"; do
             docker stack rm "$tool" 2>/dev/null
        done
        docker stack rm chatwoot-init 2>/dev/null
        show_warning "Eliminando volumen de datos de Chatwoot fallido (si existe) para un reintento limpio."
        docker volume rm chatwoot_postgres 2>/dev/null
        show_error "Error detectado durante la instalación. Limpiando archivos temporales..."
    fi
    
    for file in "${TEMP_FILES[@]}"; do
        rm -f "$file"
    done
    
    show_message "Limpieza de archivos temporales completada"
    if [ $exit_code -ne 0 ]; then
        show_error "La instalación ha fallado. Revise los logs para más información."
    fi
    exit $exit_code
}
trap 'cleanup 1' SIGINT SIGTERM EXIT
generate_random_string() {
    tr -dc A-Za-z0-9 </dev/urandom | head -c "$1"
}

# -------------------------------------------------------------------------
# 3. Función CRÍTICA de Inicialización de Chatwoot DB 
# -------------------------------------------------------------------------
initialize_chatwoot_database() {
    show_message "Iniciando base de datos de Chatwoot (Proceso avanzado con DB Health Check)..."
    
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    local postgres_volume_name="chatwoot_postgres"

    # 1. Crear stack de inicialización YML temporal (Usa pgvector)
    cat > "$init_stack_file" << EOF_INIT
version: '3.8'

services:
  # Base de Datos de Chatwoot (requiere pgvector)
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    volumes:
      - $postgres_volume_name:/var/lib/postgresql/data
    deploy:
      replicas: 1
      placement: {constraints: [node.role == manager]}
    networks: [backend]

  # Servicio temporal para ejecutar las migraciones de Rails
  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command:
      - /bin/sh
      - -c
      - |
        echo 'Esperando que PostgreSQL esté listo...'
        # Health check simple de PostgreSQL
        until PGPASSWORD="\$POSTGRES_PASSWORD" psql -h "\$POSTGRES_HOST" -p "\$POSTGRES_PORT" -U "\$POSTGRES_USERNAME" -c '\q'; do
          echo 'PostgreSQL aún no está listo. Esperando 5 segundos...'
          sleep 5
        done
        
        echo 'PostgreSQL está listo. Iniciando Chatwoot DB setup...'
        bundle exec rails db:create db:migrate db:seed
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
      - RAILS_ENV=production
      - NODE_ENV=production
    networks: [backend]
    depends_on: [chatwoot-postgres]
    deploy:
      # CRÍTICO: Asegura que el servicio se detenga después de completar el comando
      restart_policy: {condition: none}
      placement: {constraints: [node.role == manager]}

networks:
  backend: {external: true}

volumes:
  $postgres_volume_name: {external: true}
EOF_INIT
    
    register_temp_file "$init_stack_file"
    
    # 2. Crear volumen de datos (si no existe)
    if ! docker volume inspect "$postgres_volume_name" &>/dev/null; then
        run_command "docker volume create --driver local --opt type=none --opt device=$DOCKER_DIR/chatwoot/postgres_data --opt o=bind $postgres_volume_name" "Creando volumen persistente para Chatwoot DB..." || return 1
    fi

    # 3. Desplegar stack de inicialización
    run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack de inicialización temporal..." || return 1

    # Espera por completado del servicio 'chatwoot-init_chatwoot-init'
    show_message "Esperando hasta 30 minutos (1800s) para que la inicialización de Chatwoot complete su tarea..."
    local init_complete=false; local max_wait=1800; local wait_time=0
    
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
        
        if echo "$service_status" | grep -q "Complete"; then 
            init_complete=true; show_success "Inicialización de la base de datos completada exitosamente."; break
        elif echo "$service_status" | grep -q "Failed" || echo "$service_status" | grep -q "Shutdown"; then
            show_error "La inicialización de la base de datos falló o se cerró inesperadamente."
            show_message "Extrayendo logs del servicio fallido chatwoot-init_chatwoot-init para diagnóstico..."
            docker service logs chatwoot-init_chatwoot-init --tail 50
            break
        fi
        sleep 10; wait_time=$((wait_time + 10))
        show_message "Estado actual del inicializador: $service_status (Esperando $wait_time de $max_wait segundos)"
    done
    
    # 4. Limpieza
    run_command "docker stack rm chatwoot-init" "Limpiando stack temporal de inicialización..."
    sleep 5 

    if [ "$init_complete" = true ]; then
        return 0
    else
        show_error "El proceso de inicialización de la base de datos de Chatwoot falló. Revise los logs."
        return 1
    fi
}

# ------------------------------------------------
# 4. Funciones de Instalación Base
# ------------------------------------------------
check_and_install_dependencies() {
    show_message "Verificando e instalando dependencias (Docker, curl, git, net-tools)..."
    
    # Instalar curl, git y net-tools
    run_command "apt update && apt install curl git net-tools -y" "Instalando dependencias básicas (curl, git, net-tools)..." || return 1

    if ! command -v docker &> /dev/null || ! docker info &> /dev/null; then
        show_message "Instalando Docker Engine y Docker Compose..."
        curl -fsSL https://get.docker.com -o /tmp/get-docker.sh
        register_temp_file "/tmp/get-docker.sh"
        sh /tmp/get-docker.sh || { show_error "Fallo al instalar Docker."; return 1; }
    fi
    
    if ! docker info | grep -q "Swarm: active"; then
        run_command "docker swarm init" "Inicializando Docker Swarm..." || { show_error "Fallo al inicializar Swarm."; return 1; }
    fi
    show_success "Docker y Swarm están instalados y activos."
    return 0
}

install_security_tools() {
    show_message "Instalando herramientas de seguridad en el servidor: Fail2Ban y rkhunter..."
    
    # Fail2Ban: Defensa activa contra ataques de fuerza bruta
    run_command "apt install fail2ban -y" "Instalando Fail2Ban..." || return 1
    
    # rkhunter: Auditoría de rootkits
    run_command "apt install rkhunter -y" "Instalando rkhunter..." || return 1
    
    show_success "Herramientas de seguridad instaladas correctamente."
    return 0
}

initial_configuration() {
    echo -e "\n${GREEN}===========================================${NC}"
    echo -e "${GREEN}  ⚙️ Configuración Inicial del Instalador ⚙️ ${NC}"
    echo -e "${GREEN}===========================================${NC}\n"

    read -s -p "Ingrese la contraseña común para todas las herramientas y DBs: " COMMON_PASSWORD
    echo 
    read -p "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
    read -p "Ingrese una clave secreta de 32 caracteres (o presione Enter para generar una): " SECRET_KEY
    
    if [ -z "$SECRET_KEY" ]; then
        SECRET_KEY=$(generate_random_string 32)
        show_message "Se utilizará la clave generada: $SECRET_KEY"
    fi

    # Crear directorios de persistencia
    mkdir -p "$DOCKER_DIR"
    
    # Guardar variables globales en un archivo .env
    cat > "$DOCKER_DIR/.env.global" << EOF_ENV
COMMON_PASSWORD="$COMMON_PASSWORD"
SECRET_KEY="$SECRET_KEY"
BASE_DOMAIN="$BASE_DOMAIN"
EOF_ENV
    show_success "Variables de entorno guardadas en $DOCKER_DIR/.env.global"
    return 0
}

deploy_traefik_and_networks() {
    # 1. Crear redes externas
    if ! docker network ls | grep -q "proxy_network"; then
        run_command "docker network create --driver overlay proxy_network" "Creando red de proxy (proxy_network)..." || return 1
    fi
    if ! docker network ls | grep -q "backend"; then
        run_command "docker network create --driver overlay backend" "Creando red de backend (backend)..." || return 1
    fi
    
    # 2. Desplegar Traefik (usando URL)
    local traefik_stack_file="/tmp/traefik-stack.yml"
    show_message "Descargando stack de Traefik desde ${STACK_URLS[traefik]}..."
    curl -fsSL --max-time $DOWNLOAD_TIMEOUT "${STACK_URLS[traefik]}" -o "$traefik_stack_file" || { show_error "Fallo al descargar stack de Traefik."; return 1; }
    register_temp_file "$traefik_stack_file"
    
    # Sustitución de variables
    sed -i "s|BASE_DOMAIN=.*|BASE_DOMAIN=$BASE_DOMAIN|g" "$traefik_stack_file"

    # 3. Despliegue de Traefik
    run_command "docker stack deploy -c \"$traefik_stack_file\" traefik" "Desplegando Traefik y configurando certificados..." || return 1
    
    show_message "Esperando 10 segundos para que Traefik se inicie..."
    sleep 10
    return 0
}

deploy_stack() {
    local tool_name="$1"
    local stack_url="${STACK_URLS[$tool_name]}"
    local stack_file="/tmp/$tool_name-stack.yml"
    
    show_message "Descargando stack de $tool_name desde $stack_url..."
    curl -fsSL --max-time $DOWNLOAD_TIMEOUT "$stack_url" -o "$stack_file" || { show_error "Fallo al descargar stack de $tool_name."; return 1; }
    register_temp_file "$stack_file"

    # Crear directorios de persistencia (si es necesario)
    mkdir -p "$DOCKER_DIR/$tool_name"
    
    # Reemplazar variables
    sed -i "s|COMMON_PASSWORD=.*|COMMON_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|SECRET_KEY=.*|SECRET_KEY=$SECRET_KEY|g" "$stack_file"
    sed -i "s|BASE_DOMAIN=.*|BASE_DOMAIN=$BASE_DOMAIN|g" "$stack_file"
    
    # Desplegar stack
    run_command "docker stack deploy -c \"$stack_file\" \"$tool_name\"" "Desplegando $tool_name en Docker Swarm..." || return 1
    return 0
}

finalize_installation() {
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    show_message "Verifique que todos los servicios estén en estado '1/1' con 'docker service ls'."
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        subdomain="${DEFAULT_SUBDOMAINS[$i]}"
        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común (para Portainer, n8n, EvoAPI, DBs): $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"
    
    # Deshabilita el trap antes de limpiar para evitar doble salida
    trap - SIGINT SIGTERM EXIT
    cleanup 0
}

# --- 5. Función Principal ---
main() {
    if [ "$EUID" -ne 0 ]; then
        show_error "Por favor, ejecuta este script como root o con sudo."
        exit 1
    fi
    
    # 1. Instalación de dependencias y seguridad
    check_and_install_dependencies || cleanup 1
    install_security_tools || cleanup 1
    
    # 2. Configuración inicial
    initial_configuration || cleanup 1

    # 3. Despliegue de infraestructura base
    deploy_traefik_and_networks || cleanup 1
    
    # 4. Despliegue de aplicaciones
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        if [ "$tool_name" == "traefik" ]; then
            continue
        fi

        # Desplegar stack principal
        deploy_stack "$tool_name" || cleanup 1
        
        # Lógica especial para Chatwoot (Inicialización de DB)
        if [ "$tool_name" == "chatwoot" ]; then
            initialize_chatwoot_database || cleanup 1
        fi
        
        # Pausa por estabilización de servicios clave (DBs)
        if [ "$tool_name" == "redis" ] || [ "$tool_name" == "postgres" ]; then
             show_message "Esperando 10 segundos para la estabilización de $tool_name..."
             sleep 10
        fi
    done

    finalize_installation
}

# Ejecutar la función principal
main
