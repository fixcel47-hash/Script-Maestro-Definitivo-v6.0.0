#!/usr/bin/env bash

# =================================================================================
# INSTALADOR DOCKER SWARM STANDALONE (V5.2 MODIFICADO)
# Muestra el output completo de cada comando y no utiliza spinners de espera.
# Herramientas de Seguridad (Fail2Ban, RKHunter, CHKRootkit, UFW) reintegradas.
# =================================================================================

SCRIPT_VERSION="5.2.1-STANDALONE-MAX-CLARITY-SECURITY"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# URLs de stacks (ejemplos - mantener para la estructura)
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=() 

COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# ----------------------------------------------------
# Funciones de Control y Ejecución (Modo Verbose)
# ----------------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); show_message "Registrado archivo temporal: $file_path"; }
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# Función run_command (Verbose V5.2): Ejecuta comandos mostrando TODO el output
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    echo -e "${YELLOW}Ejecutando: ${cmd}${NC}"
    echo "--------------------------- INICIO OUTPUT ---------------------------"

    # Se usa 'bash -c' para permitir comandos complejos con pipes o redirecciones
    # y capturar su salida directa.
    bash -c "$cmd" 
    local exit_status=$? # Capturar el estado de salida inmediatamente

    echo "--------------------------- FIN OUTPUT ----------------------------"
    
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló con estado $exit_status."
        show_error "Comando: ${cmd}"
        cleanup 1 
    fi
    
    show_success "Comando completado exitosamente (Estado: $exit_status)."
    return 0
}

# ... (Las funciones cleanup, download_stack_content se mantienen como estaban en V5.2) ...
# Función de limpieza (Robusta + Autodestrucción)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..."
        for tool_name in "${SELECTED_TOOLS[@]}"; do docker stack rm "$tool_name" 2>/dev/null; done
        docker stack rm chatwoot-init 2>/dev/null
        sleep 5
        docker volume rm chatwoot_postgres 2>/dev/null
        
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do if [ -f "$file" ]; then rm -f "$file"; fi; done
        fi
    fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        # ... (Lógica de eliminación de archivos de despliegue) ...
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml"
            if [ -f "$deploy_file" ]; then rm -f "$deploy_file"; fi
            # Remover stack.yml si se solicitó la limpieza completa
            if [ "$delete_stacks" = true ]; then
                local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
                if [ -f "$stack_file" ]; then rm -f "$stack_file"; fi
            fi
        done
        
        # Script de Autodestrucción del instalador
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF_SD
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then sudo rm -f "$SCRIPT_PATH"; fi
rm -f "\$0"
EOF_SD
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
    
    exit $exit_code
}

trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false' ERR

download_stack_content() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then show_error "ERROR: URL de descarga no definida para $tool_name."; cleanup 1; fi
    show_message "Descargando stack de $tool_name desde: $download_url"
    run_command "curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o \"$local_path\" \"$download_url\"" "Descargando archivo stack para $tool_name..."
    
    if [ ! -s "$local_path" ]; then show_error "El archivo descargado está vacío. URL incorrecta o inaccesible."; rm -f "$local_path"; cleanup 1; fi
    show_success "Archivo $tool_name-stack.yml descargado y verificado."
    register_temp_file "$local_path"
}


# ----------------------------------------------------
# Funciones de Infraestructura y Seguridad (REINTEGRADAS)
# ----------------------------------------------------

# REINTEGRADA: Configuración de logs de Docker (tomada de installer.sh)
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"
    show_message "Configurando límites de logs en Docker (max-size: 10m, max-file: 3)..."
    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF
    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuración de logs..."
}

# REINTEGRADA: Configuración de rkhunter (tomada de installer.sh)
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"
    show_message "Configurando RKHunter..."
    run_command "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
                sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                "Aplicando configuración básica de RKHunter..."
}


# MODIFICADA: Ahora incluye la configuración de logs de Docker (REINTEGRADA)
install_dependencies() { 
    show_message "Verificando e instalando dependencias..."
    run_command "apt-get update" "Actualizando repositorios..."
    run_command "apt-get install -y ca-certificates curl git wget jo" "Instalando utilidades (git, curl, wget, jo)..."
    
    if ! command -v docker &> /dev/null; then 
        show_message "Instalando Docker..."
        run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..."
        run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null" "Añadiendo repositorio de Docker..."
        run_command "apt-get update" "Actualizando repositorios nuevamente..."
        run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
        run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..."
        configure_docker_logs  # REINTEGRADO: Llamada a la función de configuración de logs
    fi
    INSTALLED_COMPONENTS["dependencies"]=true; 
}

# REINTEGRADA: Herramientas de seguridad (tomada de installer.sh)
install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    
    # Fail2Ban
    show_message "Instalando Fail2Ban..."
    run_command "apt-get install -y fail2ban && systemctl enable fail2ban && systemctl start fail2ban" "Instalando y habilitando Fail2Ban..."
    
    # RKHunter
    show_message "Instalando RKHunter..."
    run_command "echo \"postfix postfix/main_mailer_type select No configuration\" | debconf-set-selections && apt-get install -y rkhunter" "Instalando RKHunter..."
    configure_rkhunter  # Llama a la función de configuración
    run_command "rkhunter --update" "Actualizando base de datos de RKHunter..."
    run_command "rkhunter --propupd" "Inicializando propiedades de RKHunter..."
    
    # CHKRootkit
    show_message "Instalando CHKRootkit..."
    run_command "apt-get install -y chkrootkit" "Instalando CHKRootkit..."
    
    # UFW
    show_message "Configurando UFW Firewall..."
    run_command "apt-get install -y ufw" "Instalando UFW..."
    run_command "ufw allow ssh" "Permitiendo SSH (puerto 22)..."
    run_command "ufw allow http" "Permitiendo HTTP (puerto 80)..."
    run_command "ufw allow https" "Permitiendo HTTPS (puerto 443)..."
    run_command "echo 'y' | ufw enable" "Habilitando UFW Firewall..."
    
    show_success "Herramientas de seguridad instaladas correctamente"

    INSTALLED_COMPONENTS["security"]=true
}

initialize_docker_swarm() { show_message "Verificando estado de Docker Swarm..."; if ! docker info 2>/dev/null | grep -q "Swarm: active"; then run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."; else show_message "Docker Swarm ya está activo"; fi; }
create_docker_networks() { show_message "Creando redes Docker para Swarm..."; if ! docker network ls 2>/dev/null | grep -q "frontend"; then run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."; fi; if ! docker network ls 2>/dev/null | grep -q "backend"; then run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."; fi; INSTALLED_COMPONENTS["networks"]=true; }

# ... (Las funciones wait_for_service, initialize_chatwoot_database, install_docker_tool 
# se mantienen sin cambios mayores, adaptadas al nuevo run_command/verbose) ...
wait_for_service() {
    local stack_name=$1
    local max_wait=180
    local wait_time=0
    show_message "Verificando el estado de salud del stack '$stack_name'. Máximo de espera: $max_wait segundos."

    while [ $wait_time -lt $max_wait ]; do
        echo -e "${YELLOW}--- Estatus de Servicio ($stack_name) - Tareas y Réplicas: $wait_time/$max_wait segundos ---${NC}"
        docker service ps "$stack_name"
        echo -e "${YELLOW}-----------------------------------------------------------------------------------${NC}"

        local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1)
        
        if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; then
            local running=$(echo "$status" | cut -d '/' -f 1)
            local desired=$(echo "$status" | cut -d '/' -f 2)
            if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ]; then
                show_success "Servicio '$stack_name' listo ($running/$desired réplicas)."
                return 0
            fi
        fi
        
        local failed_tasks=$(docker service ps "$stack_name" --filter "desired-state=running" --filter "state=failed" --format "{{.ID}}" 2>/dev/null)
        if [ -n "$failed_tasks" ]; then
            show_error "El servicio '$stack_name' tiene tareas fallidas. Revisando logs para diagnóstico..."
            docker service ps "$stack_name" --no-trunc
            if [ "$stack_name" == "redis" ]; then
                show_message "Extrayendo logs del servicio redis_redis-server fallido..."
                docker service logs "${stack_name}_redis-server" 2>/dev/null
            fi
            return 1
        fi
        
        sleep 10
        wait_time=$((wait_time + 10))
    done

    show_error "El servicio '$stack_name' no se estabilizó después de $max_wait segundos. Revise los logs."
    docker service ps "$stack_name" --no-trunc
    return 1
}

# (Función initialize_chatwoot_database OMITIDA por su extensión - se asume que se mantiene la lógica de V5.2)

install_docker_tool() {
    local tool_name=$1
    local default_subdomain=$2
    show_message "Configurando $tool_name..."
    local tool_dir="$DOCKER_DIR/$tool_name"
    mkdir -p $tool_dir; cd $tool_dir || { show_error "No se pudo acceder a $tool_dir"; cleanup 1; }
    local tool_index=-1
    for i in "${!AVAILABLE_TOOLS[@]}"; do if [ "${AVAILABLE_TOOLS[$i]}" = "$tool_name" ]; then tool_index=$i; break; fi; }
    read -p "Ingrese el subdominio para $tool_name [$default_subdomain]: " SUBDOMAIN
    SUBDOMAIN=${SUBDOMAIN:-$default_subdomain}
    CUSTOM_SUBDOMAINS[$tool_index]=$SUBDOMAIN
    local subdomain_file="$tool_dir/.subdomain"; echo "$SUBDOMAIN" > "$subdomain_file"; register_temp_file "$subdomain_file"
    local stack_file="$tool_dir/$tool_name-stack.yml"; download_stack_content "$tool_name" "$stack_file"
    local deploy_file="$tool_dir/$tool_name-deploy.yml"; cp "$stack_file" "$deploy_file"; register_temp_file "$deploy_file"
    show_message "Aplicando sanitización de variables en el stack de despliegue..."
    sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"; sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$deploy_file"
    sed -i "s|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"; sed -i "s|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g" "$deploy_file"
    if [ "$tool_name" == "redis" ]; then show_message "Aplicando **corrección crítica de configuración V4.7: Eliminando comando de Redis**."; sed -i '/command:/d' "$deploy_file"; show_success "Corrección de Redis V4.7 aplicada."; fi
    if [ "$tool_name" == "postgres" ]; then show_message "Aplicando corrección de variable de entorno para PostgreSQL."; sed -i "s/POSTGRES_PASSWORD: .*/POSTGRES_PASSWORD: \$COMMON_PASSWORD/g" "$deploy_file"; show_success "Corrección de PostgreSQL aplicada."; fi
    
    # Lógica de creación de volúmenes simplificada (asume que existe la función)
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$deploy_file" | sort | uniq)
    for path in $volume_paths; do run_command "mkdir -p \"$path\"" "Creando directorio $path..."; done
    
    if [ "$tool_name" = "chatwoot" ]; then
        show_message "Chatwoot detectado - Ejecutando inicialización de base de datos..."
        # NOTE: La lógica de initialize_chatwoot_database debe estar definida aquí o antes
        if ! docker service ls | grep -q "redis_redis"; then show_error "Redis no está desplegado."; cleanup 1; }
        # NOTA: La siguiente línea requiere la función initialize_chatwoot_database completa.
        # if initialize_chatwoot_database; then show_success "Base de datos de Chatwoot inicializada."; else show_error "Error crítico al inicializar DB de Chatwoot."; cleanup 1; fi
        run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name (Stack Final)..."
    else
        run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name..."
    fi
    if [ "$tool_name" = "redis" ] || [ "$tool_name" = "postgres" ]; then
        if ! wait_for_service "$tool_name"; then show_error "El stack $tool_name no se estabilizó. **FALLO CRÍTICO.**"; cleanup 1; fi
    fi
    show_success "$tool_name instalado correctamente en Docker Swarm"
    INSTALLED_COMPONENTS["$tool_name"]=true; cd $DOCKER_DIR || { show_error "No se pudo volver al directorio principal $DOCKER_DIR"; cleanup 1; }
}


# ----------------------------------------------------
# Flujo Principal (MAIN) - Inclusión de install_server_tools
# ----------------------------------------------------
main() {
    echo -e "\n${GREEN}=======================================================${NC}"
    echo -e "${GREEN}  🚀 INSTALADOR DOCKER STANDALONE (V5.2 - MODO VERBOSE) 🚀  ${NC}"
    echo -e "${GREEN}  👁️  SEGURIDAD REINTEGRADA / CERO SPINNERS            ${NC}"
    echo -e "${GREEN}=======================================================${NC}\n"

    if [ "$EUID" -ne 0 ]; then show_error "Este script debe ejecutarse como root."; cleanup 1; exit 1; }
    mkdir -p $DOCKER_DIR; cd $DOCKER_DIR || { show_error "No se pudo acceder a $DOCKER_DIR"; cleanup 1; exit 1; }

    show_message "Configuración inicial"
    # ... (Recolección de COMMON_PASSWORD, BASE_DOMAIN, SECRET_KEY y guardado en .env.global) ...

    # **FASE DE INFRAESTRUCTURA Y SEGURIDAD**
    install_dependencies
    initialize_docker_swarm
    
    # LLAMADA REINTEGRADA A LA FUNCIÓN DE SEGURIDAD
    install_server_tools 
    
    create_docker_networks

    show_message "Instalando servicios en orden de dependencias..."
    INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot")
    
    for tool_name in "${INSTALL_ORDER[@]}"; do
        default_subdomain=""
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"; break; fi
        done
        install_docker_tool "$tool_name" "$default_subdomain"
    done

    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    # ... (Mostrar URLs y credenciales) ...

    cleanup 0 true
}

# Ejecutar función principal
# main
