#!/usr/bin/env bash

# =================================================================================
# INSTALADOR DOCKER SWARM STANDALONE (V5.1 - OUTPUT DETALLADO)
# Muestra la salida completa de cada comando, eliminando el spinner y la API.
# =================================================================================

SCRIPT_VERSION="5.1.0-STANDALONE-DETAILED-OUTPUT"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# URLs COMPLETAS y CORRECTAS (Se asume la descarga directa de GitHub)
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=() 

# Variables de configuración global
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# ----------------------------------------------------
# Funciones de Control y Ejecución (Modificado para mostrar todo)
# ----------------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); }
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }


# Función de limpieza (ROBUSTA V4.9 + Autodestrucción)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        show_warning "Fallo detectado. Intentando remover stacks para evitar conflictos futuros..."
        
        # Eliminar stacks y volumen de inicialización de Chatwoot
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            docker stack rm "$tool_name" 2>/dev/null
        done
        docker stack rm chatwoot-init 2>/dev/null
        sleep 5
        
        # Intentar remover el volumen temporal de Chatwoot en caso de fallo (FIX V4.9)
        docker volume rm chatwoot_postgres 2>/dev/null
        
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then rm -f "$file"; fi
            done
        fi
    fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml"
            if [ -f "$deploy_file" ]; then rm -f "$deploy_file"; fi
        done
        
        # Lógica de autodestrucción
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF_SD
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then sudo rm -f "$SCRIPT_PATH"; fi
rm -f "\$0"
EOF_SD
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
    
    exit $exit_code
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false' ERR

# FUNCIÓN MODIFICADA: Ejecuta comandos mostrando TODO el output
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    echo -e "${YELLOW}Ejecutando: ${cmd}${NC}"
    echo "--------------------------- INICIO OUTPUT ---------------------------"

    # Ejecuta el comando directamente y muestra la salida en tiempo real
    if ! eval "$cmd"; then
        local exit_status=$?
        echo "--------------------------- FIN OUTPUT ----------------------------"
        show_error "Comando falló con estado $exit_status."
        show_error "Comando: ${cmd}"
        cleanup 1 # Llama a cleanup y sale con el estado de error
    fi
    
    echo "--------------------------- FIN OUTPUT ----------------------------"
    show_success "Comando completado exitosamente."
    return 0
}


# Función de descarga (CURL DIRECTO)
download_stack_content() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "ERROR: URL de descarga no definida para $tool_name. No se puede continuar."
        cleanup 1
    fi
    
    show_message "Descargando stack de $tool_name desde: $download_url"

    # Usamos run_command para mostrar el proceso de curl también
    run_command "curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o \"$local_path\" \"$download_url\"" "Descargando archivo stack para $tool_name..."
    
    if [ ! -s "$local_path" ]; then
        show_error "El archivo descargado está vacío o no existe. La URL es incorrecta o inaccesible."
        rm -f "$local_path"
        cleanup 1
    fi

    show_success "Archivo $tool_name-stack.yml descargado y verificado."
    register_temp_file "$local_path"
}


# ----------------------------------------------------
# Funciones de Infraestructura
# ----------------------------------------------------

install_dependencies() {
    show_message "Verificando e instalando dependencias..."
    
    run_command "apt-get update" "Actualizando repositorios..."
    run_command "apt-get install -y ca-certificates curl git wget" "Instalando utilidades (git, curl, wget)..."
    
    # Verificar si Docker está instalado
    if ! command -v docker &> /dev/null; then
        show_message "Instalando Docker..."
        run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..."
        run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null" "Añadiendo repositorio de Docker..."
        run_command "apt-get update" "Actualizando repositorios nuevamente..."
        run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
        run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..."
    fi
    
    INSTALLED_COMPONENTS["dependencies"]=true
}

initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
    else
        show_message "Docker Swarm ya está activo"
    fi
}

create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
    fi
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
    fi
    INSTALLED_COMPONENTS["networks"]=true
}

# Función para esperar a que un servicio de Swarm esté estable (ROBUSTA V4.9)
wait_for_service() {
    local stack_name=$1
    local max_wait=180
    local wait_time=0
    show_message "Verificando el estado de salud del stack '$stack_name'. Máximo de espera: $max_wait segundos."

    while [ $wait_time -lt $max_wait ]; do
        local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1)
        
        if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; then
            local running=$(echo "$status" | cut -d '/' -f 1)
            local desired=$(echo "$status" | cut -d '/' -f 2)
            
            if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ]; then
                show_success "Servicio '$stack_name' listo ($running/$desired réplicas)."
                return 0
            fi
        fi
        
        local failed_tasks=$(docker service ps "$stack_name" --filter "desired-state=running" --filter "state=failed" --format "{{.ID}}" 2>/dev/null)
        if [ -n "$failed_tasks" ]; then
            show_error "El servicio '$stack_name' tiene tareas fallidas. Revisando logs para diagnóstico..."
            # Muestra el log directamente al usuario
            docker service ps "$stack_name" --no-trunc
            if [ "$stack_name" == "redis" ]; then
                show_message "Extrayendo logs del servicio redis_redis-server fallido..."
                docker service logs "${stack_name}_redis-server" 2>/dev/null
            fi
            return 1
        fi
        
        sleep 10
        wait_time=$((wait_time + 10))
        show_message "Esperando réplicas estables de '$stack_name': Estado actual $status. (Tiempo: $wait_time/$max_wait)"
    done

    show_error "El servicio '$stack_name' no se estabilizó después de $max_wait segundos. Revise los logs."
    docker service ps "$stack_name" --no-trunc
    return 1
}

# Inicialización de la base de datos de Chatwoot (ROBUSTA V4.9)
initialize_chatwoot_database() {
    show_message "Inicializando base de datos de Chatwoot (Proceso avanzado, FIX garantizado V4.9)..."
    
    local container_id=$(docker ps -q --filter "name=redis_redis-server")
    if [ -z "$container_id" ]; then
        show_error "Redis no está desplegado. Chatwoot requiere que el stack 'redis' esté activo."; return 1
    fi

    # 1. Crear volumen externo
    run_command "docker volume create --driver local --opt type=none --opt device=$DOCKER_DIR/chatwoot/postgres_data --opt o=bind chatwoot_postgres" "Creando volumen temporal para la inicialización de Chatwoot DB..."

    # 2. Crear stack temporal
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    cat > "$init_stack_file" << EOF_INIT
version: '3.8'

services:
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    volumes:
      - chatwoot_postgres:/var/lib/postgresql/data
    deploy:
      replicas: 1
      placement:
        constraints: [node.role == manager]
    networks: [backend]

  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command: ["/bin/sh", "-c", "sleep 15 && bundle exec rails db:chatwoot_prepare"]
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
      - RAILS_ENV=production
      - NODE_ENV=production
    networks: [backend]
    depends_on: [chatwoot-postgres]
    deploy:
      restart_policy: {condition: none}
      placement: {constraints: [node.role == manager]}

networks:
  backend: {external: true}

volumes:
  chatwoot_postgres: {external: true}
EOF_INIT
    
    register_temp_file "$init_stack_file"
    
    run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack de inicialización temporal..."

    # 3. Esperar a que termine la inicialización de la DB
    show_message "Esperando a que el servicio de inicialización de Chatwoot complete su tarea..."
    local init_complete=false; local max_wait=900; local wait_time=0
    
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
        
        if echo "$service_status" | grep -q "Complete"; then
            init_complete=true; show_success "Inicialización completada."; break
        elif echo "$service_status" | grep -q "Failed" || echo "$service_status" | grep -q "Shutdown"; then
            show_error "La inicialización de la base de datos falló o se cerró inesperadamente."
            show_message "Extrayendo logs del servicio fallido chatwoot-init_chatwoot-init para diagnóstico..."
            # Muestra el log directamente al usuario
            docker service logs chatwoot-init_chatwoot-init --tail 50
            break
        fi
        
        sleep 10; wait_time=$((wait_time + 10))
        show_message "Estado actual del inicializador: $service_status (Esperando $wait_time de $max_wait segundos)"
    done
    
    # 4. Limpiar stack temporal
    run_command "docker stack rm chatwoot-init" "Limpiando stack temporal de inicialización..."
    sleep 10

    # 5. Intento robusto de eliminación de volumen (FIX V4.9)
    show_message "Intentando eliminar el volumen temporal 'chatwoot_postgres' de forma robusta..."
    local volume_removed=false;
