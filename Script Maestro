#!/bin/bash

SCRIPT_VERSION="1.3.0-AUTONOMA"

# --- Colores para mensajes ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- Variables Globales ---
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

# --- URLs de Stack Hardcodeadas ---
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [chatwoot-init]="https://github.com/user-attachments/files/22988366/chatwoot-init-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# --- Listas de Herramientas ---
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=()


# --- Funciones de Utilidad ---

# Función de limpieza (sin lógica API)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    # En caso de error, eliminar todos los archivos temporales
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then rm -f "$file"; fi
            done
        fi
    fi
    
    # Si se solicita, eliminar solo los archivos stack.yml
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then rm -f "$stack_file"; fi
        done
    fi
    
    # Script de autodestrucción
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then sudo rm -f "$SCRIPT_PATH"; fi
rm -f "\$0"
EOF
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false; exit 1' ERR

register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
    show_message "Registrado archivo temporal: $file_path"
}

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Animación de espera
spinner() {
    local pid=$1; local delay=0.1; local spinstr='|/-\'
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}; printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}; sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"; echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Función para ejecutar comandos
run_command() {
    local cmd=$1; local msg=$2
    show_message "$msg"
    eval "$cmd" > /dev/null 2>&1 &
    local cmd_pid=$!; spinner $cmd_pid; wait $cmd_pid
    local exit_status=$?
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló: $cmd"
        cleanup 1; exit $exit_status
    fi
    return $exit_status
}

# Función para generar clave aleatoria de 32 caracteres
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# Función de descarga genérica (usa curl)
download_stack_content() {
    local tool_name=$1
    local local_path=$2
    local download_url=$3

    show_message "Descargando stack de $tool_name desde: $download_url"

    if ! curl -fsSL --max-time 30 -o "$local_path" "$download_url"; then
        show_error "Fallo al descargar el archivo stack para $tool_name. Código de error: $?."
        cleanup 1; exit 1
    fi
    
    if [ ! -s "$local_path" ]; then
        show_error "El archivo descargado está vacío o no existe."
        rm -f "$local_path"
        cleanup 1; exit 1
    fi

    show_success "Archivo $tool_name-stack.yml descargado y verificado."
    register_temp_file "$local_path"
}


# --- Funciones de Instalación Base ---

# Verificar e instalar dependencias
install_dependencies() {
    show_message "Verificando e instalando dependencias..."
    apt-get update
    apt-get install -y jo
    
    if ! command -v docker &> /dev/null; then
        show_message "Instalando Docker..."
        apt-get install -y ca-certificates curl
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        configure_docker_logs
    fi
    
    apt-get install -y git curl wget
}

# Configurar tamaño de los logs de Docker
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"
    show_message "Configurando límites de logs en Docker..."
    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF
    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuración..."
}

# Inicializar Docker Swarm si no está activo
initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
    else
        show_message "Docker Swarm ya está activo"
    fi
    INSTALLED_COMPONENTS["dependencies"]=true
}

# Instalar herramientas de seguridad
install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    apt-get install -y fail2ban rkhunter chkrootkit ufw

    # Configuración Fail2Ban
    systemctl enable fail2ban; systemctl start fail2ban
    
    # Configuración RKHunter
    configure_rkhunter
    rkhunter --update
    rkhunter --propupd
    
    # Configuración UFW
    ufw allow ssh; ufw allow http; ufw allow https
    echo "y" | ufw enable
    
    show_success "Herramientas de seguridad instaladas correctamente"
    INSTALLED_COMPONENTS["security"]=true
}

# Función para configurar rkhunter (FIX para WEB_CMD)
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"
    show_message "Configurando RKHunter (Aplicando FIX para WEB_CMD)..."
    # FIX CRÍTICO: Comenta la línea 'WEB_CMD' para evitar el error de ruta relativa
    run_command "sed -i 's/^WEB_CMD=.*/#&/' \"$config_file\" && \
                sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\"" \
                "Aplicando configuración de RKHunter (FIX incluido)..."
}

# Crear redes de Docker para Swarm
create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
    else
        show_warning "La red 'frontend' ya existe"
    fi
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
    else
        show_warning "La red 'backend' ya existe"
    fi
    INSTALLED_COMPONENTS["networks"]=true
}

# Crear directorios para volúmenes
create_volume_directories() {
    local stack_file=$1
    local tool_name=$2
    show_message "Creando directorios para volúmenes de $tool_name..."
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)
    for path in $volume_paths; do
        run_command "mkdir -p \"$path\"" "Creando directorio $path..."
    done
}


# --- Funciones de Despliegue de Aplicaciones ---

# Función para inicializar la base de datos de Chatwoot
initialize_chatwoot_database() {
    show_message "Inicializando base de datos de Chatwoot..."
    
    # 1. Verificar Redis (por conexión real)
    local container_id=$(docker ps -q --filter "name=redis-server"); local redis_ready=false; local attempt=0; local max_attempts=60
    while [ $attempt -lt $max_attempts ] && [ "$redis_ready" = false ]; do
        if [ -n "$container_id" ]; then
            if docker exec "$container_id" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                redis_ready=true; show_success "Redis está listo"; break
            fi
        fi
        sleep 5; attempt=$((attempt + 1))
    done

    if [ "$redis_ready" = false ]; then show_error "Redis no está disponible"; return 1; fi
    
    # 2. Descargar y preparar el stack de inicialización
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    local init_url="${STACK_URLS[chatwoot-init]}"

    if ! download_stack_content "chatwoot-init" "$init_stack_file" "$init_url"; then
        show_error "No se pudo descargar el archivo de inicialización de Chatwoot."; return 1
    fi
    
    # Aplicar sustitución de variables (asumiendo placeholders en el YAML)
    sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$init_stack_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$init_stack_file"
    
    # 3. Desplegar el stack de inicialización
    show_message "Desplegando stack de inicialización de Chatwoot..."
    if ! docker stack deploy -c "$init_stack_file" chatwoot-init >/dev/null 2>&1; then
        show_error "Error al desplegar el stack de inicialización"; return 1
    fi

    # 4. Esperar a que la inicialización termine (servicio 'chatwoot-init_chatwoot-init')
    local init_complete=false; local max_wait=600; local wait_time=0
    show_message "Esperando a que termine la inicialización de la base de datos (max 10 min)..."
    
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
        
        if echo "$service_status" | grep -q "Complete"; then init_complete=true; break
        elif echo "$service_status" | grep -q "Failed"; then show_error "La inicialización de la base de datos falló"; break
        fi
        
        sleep 10; wait_time=$((wait_time + 10))
    done
    
    # 5. Limpiar el stack de inicialización
    show_message "Limpiando stack de inicialización..."
    docker stack rm chatwoot-init >/dev/null 2>&1; sleep 15
    
    if [ "$init_complete" = true ]; then show_success "Base de datos de Chatwoot inicializada correctamente"; return 0
    else show_error "La inicialización de la base de datos no se completó"; return 1
    fi
}

# Función para instalar una herramienta con Docker Swarm
install_docker_tool() {
    local tool_name=$1
    local default_subdomain=$2
    
    show_message "Configurando $tool_name..."
    local tool_dir="$DOCKER_DIR/$tool_name"; mkdir -p $tool_dir; cd $tool_dir || exit 1
    
    read -p "Ingrese el subdominio para $tool_name [$default_subdomain]: " SUBDOMAIN
    SUBDOMAIN=${SUBDOMAIN:-$default_subdomain}
    
    local subdomain_file="$tool_dir/.subdomain"; echo "$SUBDOMAIN" > "$subdomain_file"; register_temp_file "$subdomain_file"
    
    # Descargar stack
    local stack_file="$tool_dir/$tool_name-stack.yml"
    if ! download_stack_content "$tool_name" "$stack_file" "${STACK_URLS[$tool_name]}"; then return 1; fi
    
    local deploy_file="$tool_dir/$tool_name-deploy.yml"; cp "$stack_file" "$deploy_file"; register_temp_file "$deploy_file"

    # Reemplazar variables
    sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$deploy_file"
    sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$deploy_file"

    create_volume_directories "$deploy_file" "$tool_name"
    
    # Tratamiento especial para Chatwoot
    if [ "$tool_name" = "chatwoot" ]; then
        if ! docker service ls | grep -q "redis"; then show_error "Redis debe estar desplegado antes de instalar Chatwoot"; cleanup 1; exit 1; fi
        if ! initialize_chatwoot_database; then show_error "Error crítico al inicializar la base de datos de Chatwoot."; cleanup 1; exit 1; fi
    fi
    
    # Desplegar stack
    run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando $tool_name en Docker Swarm..."
    
    if [ $? -eq 0 ]; then
        INSTALLED_COMPONENTS["$tool_name"]=true; show_success "$tool_name instalado correctamente"
    else
        INSTALLED_COMPONENTS["$tool_name"]=false; cleanup 1; exit 1
    fi
    
    cd $DOCKER_DIR || exit 1
}


# --- Función Principal ---

main() {
    show_message "Iniciando la instalación automatizada de herramientas Docker..."

    # Verificar si el script se ejecuta como root
    if [ "$EUID" -ne 0 ]; then show_error "Este script debe ejecutarse como root"; cleanup 1; exit 1; fi
    
    # Crear directorio principal
    mkdir -p $DOCKER_DIR; cd $DOCKER_DIR || exit 1

    # 1. Configuración inicial
    show_message "Configuración inicial"
    read -p "Ingrese la contraseña común para todas las herramientas: " COMMON_PASSWORD
    if [ -z "$COMMON_PASSWORD" ]; then show_error "La contraseña no puede estar vacía"; cleanup 1; exit 1; fi

    read -p "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
    if [ -z "$BASE_DOMAIN" ]; then show_error "El dominio no puede estar vacío"; cleanup 1; exit 1; fi

    DEFAULT_SECRET_KEY=$(generate_random_key)
    read -p "Ingrese una clave secreta de 32 caracteres (o Enter para usar la generada): " SECRET_KEY
    SECRET_KEY=${SECRET_KEY:-$DEFAULT_SECRET_KEY}
    if [ ${#SECRET_KEY} -ne 32 ]; then show_warning "Clave proporcionada no tiene 32 caracteres. Usando la generada."; SECRET_KEY=$DEFAULT_SECRET_KEY; fi
    show_message "Clave secreta utilizada: $SECRET_KEY"

    env_global_file="$DOCKER_DIR/.env.global"
    cat > $env_global_file << EOL
COMMON_PASSWORD=$COMMON_PASSWORD
BASE_DOMAIN=$BASE_DOMAIN
SECRET_KEY=$SECRET_KEY
EOL

    # 2. Instalación de dependencias y seguridad
    install_dependencies
    initialize_docker_swarm
    install_server_tools
    create_docker_networks

    # 3. Instalación de servicios en orden de dependencias
    show_message "Instalando servicios en orden de dependencias..."
    INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot")
    
    for tool_name in "${INSTALL_ORDER[@]}"; do
        default_subdomain=""
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"; break; fi
        done
        
        install_docker_tool "$tool_name" "$default_subdomain"
        
        # Pausa para estabilización
        if [ "$tool_name" = "postgres" ] || [ "$tool_name" = "redis" ]; then
            show_message "Esperando a que $tool_name se estabilice..."
            sleep 15
        fi
    done

    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    # Mostrar URLs finales
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
            echo "- ${tool_name^}: https://$subdomain.$BASE_DOMAIN"
        fi
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"

    cleanup 0 true
}

# Ejecutar función principal
main
