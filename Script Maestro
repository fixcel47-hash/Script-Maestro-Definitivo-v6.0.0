#!/usr/bin/env bash

# =================================================================================
# INSTALADOR DOCKER SWARM STANDALONE (V5.3 - MODO DETALLADO CON SEGURIDAD)
# Este script es una versión completa que no requiere API, muestra todo el proceso
# e incluye la instalación de herramientas de seguridad básicas.
# =================================================================================

# --- Configuración del Script ---
SCRIPT_VERSION="5.3.0-STANDALONE-SECURITY"
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# --- Definiciones de Colores ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Sin Color

# --- Configuración de Servicios ---
# URLs para descargar los archivos YAML de los Stacks de Docker
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

# Lista de herramientas disponibles y sus subdominios por defecto
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")

# --- Variables Globales para la Entrada del Usuario ---
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

# --- Funciones Auxiliares ---

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[ÉXITO]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[AVISO]${NC} $1"; }
register_temp_file() { local file_path=$1; TEMP_FILES+=("$file_path"); }
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# --- Limpieza y Manejo de Errores ---

# Función de limpieza robusta que se ejecuta al salir o en caso de error
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    show_message "Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        show_warning "Fallo detectado. Intentando remover stacks para prevenir conflictos futuros..."
        for tool_name in "${SELECTED_TOOLS[@]}"; do docker stack rm "$tool_name" 2>/dev/null; done
        docker stack rm chatwoot-init 2>/dev/null
        sleep 5
        docker volume rm chatwoot_postgres 2>/dev/null
        
        show_error "Limpiando archivos temporales debido a un error..."
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do if [ -f "$file" ]; then rm -f "$file"; fi; done
        fi
    fi
    
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local deploy_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml"
            if [ -f "$deploy_file" ]; then rm -f "$deploy_file"; fi
        done
        
        # Lógica de autodestrucción para eliminar el script del instalador después de una ejecución exitosa
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF_SD
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then sudo rm -f "$SCRIPT_PATH"; fi
rm -f "\$0"
EOF_SD
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    show_message "Limpieza completada."
    
    if [ $exit_code -ne 0 ]; then
        show_error "La instalación ha fallado. Por favor, revise los registros."
    else
        show_success "Instalación completada exitosamente."
    fi
    
    exit $exit_code
}

# Capturar señales para asegurar que la limpieza se ejecute incluso si el script es interrumpido
trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false' ERR

# --- Funciones Principales ---

# Ejecuta un comando y muestra su salida completa para mayor detalle
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    echo -e "${YELLOW}Ejecutando: ${cmd}${NC}"
    echo "--------------------------- INICIO DE SALIDA DEL COMANDO ---------------------------"
    if ! eval "$cmd"; then
        local exit_status=$?
        echo "---------------------------- FIN DE SALIDA DEL COMANDO -----------------------------"
        show_error "El comando falló con estado de salida $exit_status."
        show_error "Comando fallido: ${cmd}"
        cleanup 1 # Salir en caso de fallo
    fi
    echo "---------------------------- FIN DE SALIDA DEL COMANDO -----------------------------"
    show_success "Comando completado exitosamente."
}

# Descarga un archivo de stack desde la URL configurada
download_stack_content() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "La URL de descarga no está definida para $tool_name."
        cleanup 1
    fi
    
    run_command "curl -fsSL --progress-bar --max-time $DOWNLOAD_TIMEOUT -o \"$local_path\" \"$download_url\"" "Descargando archivo de stack para $tool_name..."
    
    if [ ! -s "$local_path" ]; then
        show_error "El archivo descargado está vacío. La URL puede ser incorrecta o inaccesible."
        rm -f "$local_path"
        cleanup 1
    fi

    show_success "Archivo de stack para $tool_name descargado y verificado."
    register_temp_file "$local_path"
}

# Espera a que un servicio de Docker esté saludable y estable
wait_for_service() {
    local stack_name=$1
    local max_wait=180
    local wait_time=0
    show_message "Verificando la salud del stack '$stack_name'. Tiempo máximo de espera: $max_wait segundos."

    while [ $wait_time -lt $max_wait ]; do
        echo -e "${YELLOW}--- Estado del Servicio ($stack_name) - Tareas y Réplicas: ${wait_time}s / ${max_wait}s ---${NC}"
        docker service ps "$stack_name" # Muestra el estado detallado de las tareas
        echo -e "${YELLOW}-----------------------------------------------------------------------------------${NC}"

        local status=$(docker service ls --filter "name=${stack_name}" --format "{{.Replicas}}" 2>/dev/null | head -1)
        
        if [[ "$status" =~ ^[0-9]/[0-9]$ ]]; then
            local running=$(echo "$status" | cut -d '/' -f 1)
            local desired=$(echo "$status" | cut -d '/' -f 2)
            
            if [ "$running" = "$desired" ] && [ "$desired" -gt 0 ]; then
                show_success "El servicio '$stack_name' está listo ($running/$desired réplicas)."
                return 0
            fi
        fi
        
        sleep 10
        wait_time=$((wait_time + 10))
    done

    show_error "El servicio '$stack_name' no se estabilizó después de $max_wait segundos. Revise los registros."
    docker service ps "$stack_name" --no-trunc
    return 1
}

# Instala dependencias del sistema como Docker
install_dependencies() {
    show_message "Verificando e instalando dependencias..."
    run_command "apt-get update" "Actualizando repositorios de paquetes..."
    run_command "apt-get install -y ca-certificates curl git wget" "Instalando utilidades (git, curl, wget)..."
    if ! command -v docker &> /dev/null; then
        show_message "Instalando Docker..."
        run_command "install -m 0755 -d /etc/apt/keyrings && curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..."
        run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | tee /etc/apt/sources.list.d/docker.list > /dev/null" "Añadiendo repositorio de Docker..."
        run_command "apt-get update" "Actualizando repositorios de paquetes nuevamente..."
        run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
        run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..."
    fi
}

# Instala y configura herramientas básicas de seguridad
install_security_tools() {
    show_message "Instalando y configurando herramientas de seguridad..."

    # --- UFW (Firewall) ---
    run_command "apt-get install -y ufw" "Instalando UFW (Uncomplicated Firewall)..."
    run_command "ufw allow 22/tcp" "Permitiendo conexiones SSH (puerto 22)..."
    run_command "ufw allow 80/tcp" "Permitiendo tráfico HTTP (puerto 80)..."
    run_command "ufw allow 443/tcp" "Permitiendo tráfico HTTPS (puerto 443)..."
    show_warning "Docker Swarm requiere puertos específicos. Abriéndolos ahora..."
    run_command "ufw allow 2377/tcp" "Permitiendo puerto 2377/tcp para gestión del clúster Swarm..."
    run_command "ufw allow 7946/tcp" "Permitiendo puerto 7946/tcp para comunicación entre nodos..."
    run_command "ufw allow 7946/udp" "Permitiendo puerto 7946/udp para descubrimiento de nodos..."
    run_command "ufw allow 4789/udp" "Permitiendo puerto 4789/udp para la red overlay..."
    run_command "echo 'y' | ufw enable" "Habilitando el firewall..."
    run_command "ufw status" "Verificando el estado del firewall..."
    show_success "UFW configurado y habilitado."

    # --- Fail2Ban ---
    run_command "apt-get install -y fail2ban" "Instalando Fail2Ban..."
    JAIL_LOCAL="/etc/fail2ban/jail.local"
    if [ ! -f "$JAIL_LOCAL" ]; then
        show_message "Creando configuración local para Fail2Ban (jail.local)..."
        echo -e "[sshd]\nenabled = true\nport = ssh\nlogpath = %(sshd_log)s\nbackend = %(sshd_backend)s" > "$JAIL_LOCAL"
    fi
    run_command "systemctl enable fail2ban && systemctl start fail2ban" "Habilitando e iniciando Fail2Ban..."
    run_command "systemctl status fail2ban" "Verificando el estado de Fail2Ban..."
    show_success "Fail2Ban instalado y configurado para proteger SSH."

    # --- RKHunter (Rootkit Hunter) ---
    run_command "apt-get install -y rkhunter" "Instalando RKHunter..."
    run_command "rkhunter --propupd" "Actualizando la base de datos de propiedades de archivos de RKHunter..."
    show_message "Realizando un escaneo inicial con RKHunter (esto puede tardar unos minutos)..."
    run_command "rkhunter --check --sk" "Ejecutando el escaneo del sistema..."
    show_success "RKHunter instalado y escaneo inicial completado. Revise los registros en /var/log/rkhunter.log"
}

# Inicializa el modo Docker Swarm si no está activo
initialize_docker_swarm() {
    show_message "Verificando el estado de Docker Swarm..."
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
    else
        show_message "Docker Swarm ya está activo."
    fi
}

# Crea las redes overlay requeridas por los stacks
create_docker_networks() {
    show_message "Creando redes overlay de Docker para Swarm..."
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando la red 'frontend'..."
    fi
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando la red 'backend'..."
    fi
}

# Maneja el proceso especial de inicialización de la base de datos para Chatwoot
initialize_chatwoot_database() {
    show_message "Inicializando la base de datos de Chatwoot (Proceso avanzado)..."
    run_command "docker volume create --driver local --opt type=none --opt device=$DOCKER_DIR/chatwoot/postgres_data --opt o=bind chatwoot_postgres" "Creando volumen temporal para la inicialización de la BD de Chatwoot..."
    
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    # Crear un archivo de stack temporal para el proceso de inicialización de la BD
    cat > "$init_stack_file" << EOF_INIT
version: '3.8'
services:
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
    volumes: [chatwoot_postgres:/var/lib/postgresql/data]
    deploy: {replicas: 1, placement: {constraints: [node.role == manager]}}
    networks: [backend]
  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command: ["/bin/sh", "-c", "sleep 15 && bundle exec rails db:chatwoot_prepare"]
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
    networks: [backend]
    depends_on: [chatwoot-postgres]
    deploy: {restart_policy: {condition: none}}
networks:
  backend: {external: true}
volumes:
  chatwoot_postgres: {external: true}
EOF_INIT
    register_temp_file "$init_stack_file"

    run_command "docker stack deploy -c \"$init_stack_file\" chatwoot-init" "Desplegando stack de inicialización temporal..."
    
    # Esperar a que la tarea de inicialización única se complete
    local init_complete=false; max_wait=900; wait_time=0
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        local service_status=$(docker service ps chatwoot-init_chatwoot-init --format "{{.CurrentState}}" --no-trunc 2>/dev/null | head -1)
        if echo "$service_status" | grep -q "Complete"; then 
            init_complete=true; 
            show_success "Tarea de inicialización de la base de datos completada.";
            break;
        fi
        sleep 10; wait_time=$((wait_time + 10))
        show_message "Estado actual del inicializador: $service_status (Esperando ${wait_time}s de ${max_wait}s)"
    done

    run_command "docker stack rm chatwoot-init" "Limpiando stack de inicialización temporal..."
    sleep 10
    run_command "docker volume rm chatwoot_postgres" "Eliminando volumen de base de datos temporal..."

    if [ "$init_complete" = true ]; then return 0; else return 1; fi
}

# Función principal para instalar una única herramienta
install_docker_tool() {
    local tool_name=$1
    local default_subdomain=$2
    show_message "Configurando $tool_name..."
    
    local tool_dir="$DOCKER_DIR/$tool_name"
    mkdir -p $tool_dir; cd $tool_dir || { show_error "No se pudo acceder a $tool_dir"; cleanup 1; }

    read -p "Ingrese el subdominio para $tool_name [$default_subdomain]: " SUBDOMAIN
    SUBDOMAIN=${SUBDOMAIN:-$default_subdomain}
    
    local stack_file="$tool_dir/$tool_name-stack.yml"
    download_stack_content "$tool_name" "$stack_file"
    
    local deploy_file="$tool_dir/$tool_name-deploy.yml"
    cp "$stack_file" "$deploy_file"; register_temp_file "$deploy_file"
    
    show_message "Aplicando la configuración del usuario al archivo del stack..."
    sed -i "s|REPLACE_PASSWORD|$COMMON_PASSWORD|g" "$deploy_file"
    sed -i "s|REPLACE_SUBDOMAIN|$SUBDOMAIN|g" "$deploy_file"
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$deploy_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$deploy_file"

    # Crear directorios para los volúmenes persistentes
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$deploy_file" | sort | uniq)
    for path in $volume_paths; do run_command "mkdir -p \"$path\"" "Creando directorio de volumen $path..."; done
    
    # Manejar el caso especial de inicialización de Chatwoot
    if [ "$tool_name" = "chatwoot" ]; then
        show_message "Chatwoot requiere inicialización de la base de datos..."
        if ! initialize_chatwoot_database; then 
            show_error "Error crítico durante la inicialización de la BD de Chatwoot.";
            cleanup 1;
        fi
    fi

    run_command "docker stack deploy -c \"$deploy_file\" $tool_name" "Desplegando el stack de $tool_name..."
    
    # Para infraestructura crítica como bases de datos, esperar a que estén saludables
    if [ "$tool_name" = "redis" ] || [ "$tool_name" = "postgres" ]; then
        if ! wait_for_service "$tool_name"; then 
            show_error "El stack de $tool_name falló al estabilizarse. Esto es un fallo crítico."; 
            cleanup 1;
        fi
    fi
    show_success "$tool_name se ha instalado correctamente."
    cd $DOCKER_DIR || { show_error "No se pudo volver al directorio principal $DOCKER_DIR"; cleanup 1; }
}

# --- Lógica de Ejecución Principal ---
main() {
    echo -e "\n${GREEN}========================================================================${NC}"
    echo -e "${GREEN}  🚀 INSTALADOR DOCKER STANDALONE (V5.3 - MODO SEGURO Y DETALLADO) 🚀  ${NC}"
    echo -e "${GREEN}  👀 Este script mostrará todos los procesos, registros y segurizará el servidor.     ${NC}"
    echo -e "${GREEN}========================================================================${NC}\n"

    # 1. Verificar privilegios de root
    if [ "$EUID" -ne 0 ]; then show_error "Este script debe ejecutarse como root."; exit 1; fi
    mkdir -p $DOCKER_DIR; cd $DOCKER_DIR || { show_error "No se pudo acceder a $DOCKER_DIR"; exit 1; }

    # 2. Recopilar información del usuario
    show_message "Configuración Inicial"
    read -sp "Ingrese una contraseña común para todas las herramientas: " COMMON_PASSWORD; echo
    if [ -z "$COMMON_PASSWORD" ]; then show_error "La contraseña no puede estar vacía"; exit 1; fi
    read -p "Ingrese el dominio base (ej: midominio.com): " BASE_DOMAIN
    if [ -z "$BASE_DOMAIN" ]; then show_error "El dominio no puede estar vacío"; exit 1; fi
    DEFAULT_SECRET_KEY=$(generate_random_key)
    read -p "Ingrese una clave secreta de 32 caracteres (o presione Enter para generar una): " SECRET_KEY
    SECRET_KEY=${SECRET_KEY:-$DEFAULT_SECRET_KEY}
    show_message "Usando la clave secreta: $SECRET_KEY"

    # 3. Guardar variables de entorno
    env_global_file="$DOCKER_DIR/.env.global"
    echo "COMMON_PASSWORD=$COMMON_PASSWORD" > "$env_global_file"
    echo "BASE_DOMAIN=$BASE_DOMAIN" >> "$env_global_file"
    echo "SECRET_KEY=$SECRET_KEY" >> "$env_global_file"
    show_success "Variables globales guardadas en $env_global_file"

    # 4. Configurar el entorno
    install_dependencies
    install_security_tools
    initialize_docker_swarm
    create_docker_networks

    # 5. Instalar herramientas en orden de dependencia
    show_message "Instalando servicios..."
    INSTALL_ORDER=("traefik" "redis" "postgres" "portainer" "n8n" "evoapi" "chatwoot")
    
    for tool_name in "${INSTALL_ORDER[@]}"; do
        default_subdomain=""
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then 
                default_subdomain="${DEFAULT_SUBDOMAINS[$j]}"; 
                break; 
            fi
        done
        install_docker_tool "$tool_name" "$default_subdomain"
    done

    # 6. Mostrar resumen final
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo "Puedes acceder a tus servicios en las siguientes URLs:"
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        # Esta parte necesita ser mejorada para leer el subdominio guardado
        # Por ahora, dependerá de los valores predeterminados. Una solución más robusta leería desde un archivo de estado.
        echo "- ${tool_name^}: (Revisa los registros para el subdominio específico utilizado)"
    done
    
    echo ""
    echo "Información de Credenciales:"
    echo "- Contraseña Común: $COMMON_PASSWORD"
    echo "- Clave Secreta: $SECRET_KEY"
    echo "Esta información está guardada en: $DOCKER_DIR/.env.global"
    echo "==========================================="

    # 7. Limpieza final de archivos temporales
    cleanup 0 true
}

# --- Iniciar Script ---
main

