#!/bin/bash

SCRIPT_VERSION="3.0.3"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables API
API_URL="https://tkinstall.emodev.link/api"
API_TOKEN=""
INSTALLATION_ID=""

# Obtener ruta absoluta del script actual
SCRIPT_PATH=$(readlink -f "$0")

# Lista de archivos temporales para limpiar
TEMP_FILES=()

declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# Función de limpieza
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado durante la instalación. Limpiando archivos temporales..."
        if [ ! -z "$INSTALLATION_ID" ]; then
            update_installation_status "failed" ""
        fi
        
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
        done
    fi
    
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF
        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalación ha fallado. Revise los logs para más información."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalación completada exitosamente"
    fi
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false; exit 1' ERR

# ... (El resto de las funciones auxiliares como register_temp_file, collect_system_info, etc. se mantienen igual) ...

# Funciones de visualización y comando
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
spinner() { local pid=$1; local delay=0.1; local spinstr='|/-\'; echo -n "Procesando "; while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do local temp=${spinstr#?}; printf " [%c]  " "$spinstr"; local spinstr=$temp${spinstr%"$temp"}; sleep $delay; printf "\b\b\b\b\b\b"; done; printf "    \b\b\b\b"; echo -e "${GREEN}[COMPLETADO]${NC}"; }
run_command() {
    local cmd=$1
    local msg=$2
    show_message "$msg"
    eval "$cmd" > /dev/null 2>&1 &
    local cmd_pid=$!
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló: $cmd"
        cleanup 1
        exit $exit_status
    fi
    return $exit_status
}
generate_random_key() { tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32; }

# Función para descargar archivos desde la API (con verificación de robustez)
download_from_api() {
    local repo_path=$1
    local local_path=$2
    
    show_message "Descargando $repo_path..."
    
    response=$(curl -s -w "%{http_code}" -H "x-api-token: $API_TOKEN" "$API_URL/file/$repo_path")

    http_code=$(tail -n1 <<< "$response")
    content=$(sed '$ d' <<< "$response")
    
    if [ "$http_code" -ne 200 ]; then
        show_error "Error al descargar $repo_path (Código $http_code): $content"
        cleanup 1
        exit 1
    fi
    
    echo "$content" > "$local_path"
    register_temp_file "$local_path"
    
    # === VERIFICACIÓN DE ROBUSTEZ AÑADIDA ===
    if [ ! -f "$local_path" ] || [ ! -s "$local_path" ]; then
        show_error "El archivo descargado $repo_path está vacío o no se guardó correctamente. Saliendo."
        cleanup 1
        exit 1
    fi
    # ========================================

    show_success "Archivo $repo_path descargado correctamente"
    return 0
}

# ... (Las funciones validate_token, install_dependencies, initialize_docker_swarm, install_server_tools, create_docker_networks, create_volume_directories, initialize_chatwoot_database se mantienen igual) ...

# ----------------------------------------------------------------------
# FUNCIONES CRÍTICAS (SANEAR E INSTALAR)
# ----------------------------------------------------------------------

# Función para sanear y desplegar cada herramienta
install_tool() {
    local tool_name=$1
    local subdomain=$2
    local stack_dir="$DOCKER_DIR/$tool_name"
    local stack_file="$stack_dir/$tool_name-stack.yml"
    
    show_message "Preparando instalación de $tool_name con subdominio: $subdomain.$BASE_DOMAIN"

    mkdir -p "$stack_dir"
    download_from_api "$tool_name-stack.yml" "$stack_file"

    # Sanitización general de variables de Traefik y Secrets
    sed -i "s/REPLACE_SUBDOMAIN/$subdomain/g" "$stack_file"
    sed -i "s/REPLACE_DOMAIN/$BASE_DOMAIN/g" "$stack_file"
    sed -i "s/REPLACE_PASSWORD/$COMMON_PASSWORD/g" "$stack_file"
    sed -i "s/REPLACE_SECRET_KEY/$SECRET_KEY/g" "$stack_file"

    # Crear directorios para volúmenes
    create_volume_directories "$stack_file" "$tool_name"

    # Manejo de casos especiales (donde ocurrió el error)
    if [ "$tool_name" == "redis" ]; then
        show_message "Aplicando corrección de sintaxis para Redis..."

        # 1. Corregir redis-server: Añadir la contraseña al comando
        sed -i "s/command: redis-server --loglevel warning/command: redis-server --requirepass \$COMMON_PASSWORD --loglevel warning/g" "$stack_file"

        # 2. Corregir redisinsight: Inyectar variables de entorno con indentación correcta
        # Se inyecta DESPUÉS de la línea de la imagen y ANTES del bloque 'deploy'
        sed -i '/image: redislabs\/redisinsight:latest/a\    environment:\n      - REDISINSIGHT_PASSWORD=\$COMMON_PASSWORD\n      - REDIS_PASSWORD=\$COMMON_PASSWORD' "$stack_file"
        
        show_success "Corrección de Redis aplicada"
    fi

    if [ "$tool_name" == "n8n" ]; then
        show_message "Aplicando correcciones de ruta para n8n..."
        # Corrección: Asegurar que las rutas de los subdominios de webhook sean correctas.
        sed -i "s/REPLACE_WEBHOOK_SUBDOMAIN/webhook.$subdomain/g" "$stack_file"
        show_success "Corrección de n8n aplicada"
    fi

    # Desplegar el stack
    show_message "Desplegando $tool_name en Docker Swarm..."
    run_command "docker stack deploy -c $stack_file $tool_name" "Desplegando $tool_name..."
    
    if [ $? -eq 0 ]; then
        show_success "$tool_name instalado correctamente en Docker Swarm"
        echo "$subdomain" > "$DOCKER_DIR/$tool_name/.subdomain"
        return 0
    else
        show_error "Fallo al desplegar $tool_name"
        cleanup 1
        exit 1
    fi
}

# ----------------------------------------------------------------------
# LÓGICA DE EJECUCIÓN PRINCIPAL
# ----------------------------------------------------------------------

# ... (Código para verificar root, crear DOCKER_DIR, solicitar DOMAIN/PASSWORD/KEY, etc. se mantiene igual) ...

# Ejecución principal del script
main_installation_flow() {
    # 1. Validación e Inicialización
    validate_token || exit 1
    register_installation_start || exit 1
    
    # 2. Requerimientos del servidor
    install_dependencies
    initialize_docker_swarm
    install_server_tools
    create_docker_networks
    
    # 3. Instalación de herramientas (Bucle principal)
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        default_subdomain="${DEFAULT_SUBDOMAINS[$i]}"
        
        # En el script original se debe solicitar/usar el subdominio
        # Por simplicidad, aquí usamos el predeterminado para el flujo
        subdomain_to_use=$default_subdomain
        
        install_tool "$tool_name" "$subdomain_to_use"
        
        # 4. Post-instalación (Solo Chatwoot requiere inicialización)
        if [ "$tool_name" == "chatwoot" ]; then
            initialize_chatwoot_database "$subdomain_to_use"
        fi
    done

    # 5. Finalización y limpieza
    complete_installation
    finalize_installation
}

# Función para el mensaje final (adaptada)
finalize_installation() {
    # ... (Se mantiene el código para mostrar URLs y credenciales finales) ...
    
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        tool_index=$i

        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${DEFAULT_SUBDOMAINS[$tool_index]}"
        fi

        # Capitalizar el nombre de la herramienta
        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"

    cleanup 0 true # El parámetro 'true' indica que elimine los archivos stack.yml en caso de éxito
}

# Llamada a la función principal
main_installation_flow
