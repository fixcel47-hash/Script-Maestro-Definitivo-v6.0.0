#!/bin/bash

# ==========================================================
# Instalador de Herramientas Docker - Versión Standalone
# CORREGIDO: Error de sintaxis en create_volume_directories
# ==========================================================

SCRIPT_VERSION="1.2.1-standalone-fixed"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# URLs de los archivos de configuración de Docker (GitHub)
declare -gA STACK_URLS=(
    ["chatwoot"]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    ["evoapi"]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    ["n8n"]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    ["portainer"]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    ["postgres"]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    ["redis"]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    ["traefik"]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

# Variables de la instalación
SCRIPT_PATH=$(readlink -f "$0")
DOCKER_DIR="/home/docker"

# Lista de archivos temporales para limpiar
TEMP_FILES=()

declare -gA INSTALLED_COMPONENTS=(
    [dependencies]=false
    [security]=false
    [networks]=false
)

# Lista de herramientas disponibles y seleccionadas
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=() # Array para almacenar los subdominios personalizados

# Variables de configuración global (se establecen en main)
COMMON_PASSWORD=""
BASE_DOMAIN=""
SECRET_KEY=""

# ----------------------------------------------------
# Funciones de Mensajería
# ----------------------------------------------------

# Función para mostrar mensajes
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }

# Función para mostrar errores
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Función para mostrar éxito
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }

# Función para mostrar advertencias
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# ----------------------------------------------------
# Funciones de Soporte
# ----------------------------------------------------

# Función de limpieza
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false} # Segundo parámetro opcional, por defecto false
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    # En caso de error, eliminar todos los archivos temporales
    if [ $exit_code -ne 0 ]; then
        show_error "Error detectado durante la instalación. Limpiando archivos temporales..."
        
        # Eliminar archivos temporales
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    # Si se solicita (en caso de éxito), eliminar los archivos de stack generados
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-deploy.yml" # Cambiado a -deploy.yml
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
            # También eliminamos el archivo de subdominio
            local subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
            if [ -f "$subdomain_file" ]; then
                rm -f "$subdomain_file"
            fi
        done
        # Eliminar el archivo .env.global
        if [ -f "$DOCKER_DIR/.env.global" ]; then
            rm -f "$DOCKER_DIR/.env.global"
        fi
    fi
    
    # Crear un script de autodestrucción (para error y éxito)
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF

        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        show_error "La instalación ha fallado. Revise los logs para más información."
    else
        show_success "Instalación completada exitosamente 🎉"
    fi
    
    exit $exit_code
}

# Configurar trampas para señales para limpiar antes de salir
trap 'cleanup 1 false' SIGHUP SIGINT SIGQUIT SIGTERM
trap 'cleanup 1 false' ERR

# Función para registrar un archivo temporal para limpieza posterior
register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
}

# Función para animación de espera
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Función para ejecutar comandos mostrando animación de espera
run_command() {
    local cmd=$1
    local msg=$2
    
    show_message "$msg"
    # Ejecuta el comando en un subshell en segundo plano
    ( eval "$cmd" ) > /tmp/installer_cmd_log_$$ 2>&1 &
    local cmd_pid=$!
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    
    # Si el comando falla, mostrar logs y salir
    if [ $exit_status -ne 0 ]; then
        show_error "Comando falló: $cmd"
        show_error "Logs del comando:"
        cat /tmp/installer_cmd_log_$$ | tail -n 10
        rm -f /tmp/installer_cmd_log_$$
        cleanup 1
    fi
    
    rm -f /tmp/installer_cmd_log_$$
    return $exit_status
}

# Función para generar clave aleatoria de 32 caracteres
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# Función para configurar tamaño de los logs de Docker
configure_docker_logs() {
    local config_file="/etc/docker/daemon.json"

    show_message "Configurando límites de logs en Docker..."

    cat > "$config_file" <<EOF
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF

    run_command "systemctl restart docker" "Reiniciando Docker para aplicar configuración..."
}

# Función para configurar rkhunter
configure_rkhunter() {
    local config_file="/etc/rkhunter.conf"

    show_message "Configurando RKHunter..."

    run_command "sed -i 's/^UPDATE_MIRRORS=.*/UPDATE_MIRRORS=1/' \"$config_file\" && \
                sed -i 's/^MIRRORS_MODE=.*/MIRRORS_MODE=0/' \"$config_file\" && \
                sed -i 's|^WEB_CMD=.*|WEB_CMD=\"\"|' \"$config_file\"" \
                "Aplicando configuración de RKHunter..."
}

# Función para descargar archivos desde las URLs de GitHub
download_from_url() {
    local url=$1
    local local_path=$2
    
    show_message "Descargando $url..."
    
    curl -fsSL -o "$local_path" "$url"
    
    if [ $? -ne 0 ]; then
        show_error "Error al descargar $url"
        cleanup 1
    fi
    
    # Registrar el archivo como temporal
    register_temp_file "$local_path"
    show_success "Archivo descargado correctamente: $local_path"
}

# ----------------------------------------------------
# Lógica de Instalación
# ----------------------------------------------------

# Verificar e instalar dependencias
install_dependencies() {
    show_message "Verificando e instalando dependencias..."
    
    run_command "apt-get update" "Actualizando repositorios..."

    # Instalar jo para creacion de json (simplemente para mantener el flujo original si se necesitara, aunque no se usa en el standalone)
    run_command "apt-get install -y jo" "Instalando jo (utilidad JSON)..."
    
    # Verificar si Docker está instalado
    if ! command -v docker &> /dev/null; then
        show_message "Instalando Docker..."
        run_command "apt-get install -y ca-certificates curl" "Instalando requisitos para Docker..."
        run_command "install -m 0755 -d /etc/apt/keyrings" "Creando directorio de keyrings..."
        run_command "curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc && \
                    chmod a+r /etc/apt/keyrings/docker.asc" "Descargando clave GPG de Docker..."
        run_command "echo \"deb [arch=\$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
                    \$(. /etc/os-release && echo \"\$VERSION_CODENAME\") stable\" | \
                    sudo tee /etc/apt/sources.list.d/docker.list > /dev/null" "Añadiendo repositorio de Docker..."
        run_command "apt-get update" "Actualizando repositorios nuevamente..."
        run_command "apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin" "Instalando paquetes de Docker..."
        run_command "systemctl enable docker && systemctl start docker" "Habilitando e iniciando Docker..."

        configure_docker_logs
    fi
    
    # Instalar otras herramientas necesarias
    run_command "apt-get install -y git curl wget" "Instalando utilidades adicionales (git, curl, wget)..."
}

# Inicializar Docker Swarm si no está activo
initialize_docker_swarm() {
    show_message "Verificando estado de Docker Swarm..."
    
    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        show_message "Iniciando Docker Swarm..."
        run_command "docker swarm init --advertise-addr \$(hostname -I | awk '{print \$1}')" "Inicializando Docker Swarm..."
        show_success "Docker Swarm inicializado correctamente"
    else
        show_message "Docker Swarm ya está activo"
    fi

    INSTALLED_COMPONENTS["dependencies"]=true
}

# Instalar herramientas directamente en el servidor
install_server_tools() {
    show_message "Instalando herramientas de seguridad en el servidor..."
    
    # Fail2Ban
    run_command "apt-get install -y fail2ban && systemctl enable fail2ban && systemctl start fail2ban" "Instalando y activando Fail2Ban..."
    
    # RKHunter
    run_command "echo \"postfix postfix/main_mailer_type select No configuration\" | debconf-set-selections && apt-get install -y rkhunter" "Instalando RKHunter..."
    configure_rkhunter
    run_command "rkhunter --update" "Actualizando base de datos de RKHunter..."
    run_command "rkhunter --propupd" "Actualizando base de datos de propiedades de RKHunter..."
    
    # CHKRootkit
    run_command "apt-get install -y chkrootkit" "Instalando CHKRootkit..."
    
    # UFW
    show_message "Configurando UFW Firewall..."
    run_command "apt-get install -y ufw" "Instalando UFW..."
    run_command "ufw allow ssh && ufw allow http && ufw allow https" "Permitiendo SSH, HTTP y HTTPS..."
    run_command "echo \"y\" | ufw enable" "Activando UFW..."
    
    show_success "Herramientas de seguridad instaladas correctamente"

    INSTALLED_COMPONENTS["security"]=true
}

# Crear redes de Docker para Swarm
create_docker_networks() {
    show_message "Creando redes Docker para Swarm..."
    
    if ! docker network ls 2>/dev/null | grep -q "frontend"; then
        run_command "docker network create --driver overlay --attachable frontend" "Creando red frontend..."
        show_success "Red 'frontend' creada"
    else
        show_warning "La red 'frontend' ya existe"
    fi
    
    if ! docker network ls 2>/dev/null | grep -q "backend"; then
        run_command "docker network create --driver overlay --attachable backend" "Creando red backend..."
        show_success "Red 'backend' creada"
    else
        show_warning "La red 'backend' ya existe"
    fi

    INSTALLED_COMPONENTS["networks"]=true
}

# Función para crear directorios para volúmenes
create_volume_directories() {
    local deploy_file=$1
    local tool_name=$2

    show_message "Creando directorios para volúmenes de $tool_name..."

    # Buscar todas las rutas de volúmenes en el archivo de stack
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$deploy_file" | sort | uniq)

    if [ -z "$volume_paths" ]; then
        show_message "No se encontraron rutas de volúmenes para $tool_name"
        return
    fi # <--- CORRECCIÓN APLICADA: Cierre correcto del bloque if

    for path in $volume_paths; do
        show_message "Creando directorio: $path"
        run_command "mkdir -p \"$path\"" "Creando directorio $path..."
    done
}

# Función para inicializar la base de datos de Chatwoot
initialize_chatwoot_database() {
    local tool_name="chatwoot"
    local subdomain=$1
    
    show_message "Inicializando base de datos de Chatwoot..."
    
    # 1. Verificar disponibilidad de Redis (por nombre de servicio/contenedor)
    show_message "Verificando disponibilidad de Redis..."
    local container_id=""
    local redis_attempt=0
    local max_attempts=60
    
    while [ $redis_attempt -lt $max_attempts ]; do
        container_id=$(docker ps -q --filter "name=redis_redis-server")
        if [ -n "$container_id" ]; then
            # Verificar con redis-cli, si está disponible
            if docker exec "$container_id" redis-cli ping 2>/dev/null | grep -q "PONG"; then
                show_success "Redis está listo"
                break
            fi
        fi
        
        sleep 5
        redis_attempt=$((redis_attempt + 1))
        if [ $redis_attempt -ge $max_attempts ]; then
            show_error "Redis no está disponible después de 5 minutos (o 60 intentos)"
            return 1
        fi
        if [ $((redis_attempt % 12)) -eq 0 ]; then
            show_message "Esperando Redis... ($((redis_attempt * 5))/300 segundos)"
        fi
    done
    
    if [ $redis_attempt -ge $max_attempts ]; then
        return 1
    fi
    
    # 2. Crear stack temporal solo para inicializar la base de datos
    show_message "Creando stack temporal para inicialización de base de datos..."
    
    local init_stack_file="/tmp/chatwoot-init-stack.yml"
    
    cat > "$init_stack_file" << EOF
version: '3.8'

services:
  chatwoot-postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_DB=chatwoot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
      
    volumes:
      - chatwoot_postgres:/var/lib/postgresql/data
      
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
      placement:
        constraints:
          - node.role == manager
    networks:
      - backend

  chatwoot-init:
    image: chatwoot/chatwoot:latest
    command: ["bundle", "exec", "rails", "db:chatwoot_prepare"]
    environment:
      - POSTGRES_HOST=chatwoot-postgres
      - POSTGRES_PORT=5432
      - POSTGRES_DATABASE=chatwoot
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$COMMON_PASSWORD
      - REDIS_URL=redis://redis-server:6379/4
      - SECRET_KEY_BASE=$SECRET_KEY
      - RAILS_ENV=production
      - NODE_ENV=production
    networks:
      - backend
    depends_on:
      - chatwoot-postgres
    deploy:
      restart_policy:
        condition: none
      placement:
        constraints:
          - node.role == manager

networks:
  backend:
    external: true

volumes:
  chatwoot_postgres:
    driver: local
    driver_opts:
      type: none
      device: $DOCKER_DIR/chatwoot/postgres_data
      o: bind
EOF
    
    register_temp_file "$init_stack_file"
    
    # Crear el directorio de volumen para PostgreSQL de Chatwoot antes de desplegar
    run_command "mkdir -p $DOCKER_DIR/chatwoot/postgres_data" "Creando directorio de volumen para PostgreSQL de Chatwoot..."
    
    # 3. Desplegar el stack de inicialización
    show_message "Desplegando stack de inicialización de Chatwoot..."
    if ! docker stack deploy -c "$init_stack_file" chatwoot-init >/dev/null 2>&1; then
        show_error "Error al desplegar el stack de inicialización"
        return 1
    fi

    show_success "Stack de inicialización desplegado"
    
    # 4. Esperar a que el contenedor de PostgreSQL esté corriendo y disponible
    local postgres_container_id=""
    local pg_ready=false
    local max_pg_wait=60 # 5 minutos para que PostgreSQL esté disponible

    show_message "Esperando a que el contenedor de PostgreSQL inicie y esté listo..."
    for i in $(seq 1 $max_pg_wait); do
        postgres_container_id=$(docker ps -q --filter "name=chatwoot-init_chatwoot-postgres")
        if [ -n "$postgres_container_id" ]; then
            # Verificar conexión a PostgreSQL usando pg_isready
            if docker exec "$postgres_container_id" pg_isready -U postgres -h localhost >/dev/null 2>&1; then
                pg_ready=true
                show_success "PostgreSQL para Chatwoot está listo"
                sleep 10 # Espera adicional para asegurar estabilidad
                break
            fi
        fi
        sleep 5
        if [ $((i % 12)) -eq 0 ]; then
             show_message "Esperando PostgreSQL... ($((i * 5))/300 segundos)"
        fi
    done

    if [ "$pg_ready" = false ]; then
        show_error "PostgreSQL no está disponible después de 5 minutos"
        docker stack rm chatwoot-init >/dev/null 2>&1
        return 1
    fi
        
    # 5. Esperar a que termine la inicialización de la base de datos
    show_message "Esperando a que termine la inicialización de la base de datos..."
    local init_complete=false
    local max_wait=600 # 10 minutos máximo para la inicialización
    local wait_time=0
    
    while [ $wait_time -lt $max_wait ] && [ "$init_complete" = false ]; do
        # Verificar si el servicio ha terminado exitosamente
