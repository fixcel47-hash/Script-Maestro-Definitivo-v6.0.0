#!/usr/bin/env bash
# =================================================================================
# UNIFIED INSTALLER SCRIPT (v3.0.3 - FINAL Y ROBUSTO)
# Corrige: Sintaxis YAML de Redis y robustez en la descarga de archivos.
# 隆Script independiente sin API ni tokens!
# =================================================================================

SCRIPT_VERSION="3.0.3-FINAL"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
SCRIPT_PATH=$(readlink -f "$0")
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# Configuracion de URLs para descarga de Stacks
# 隆Descarga directa desde GitHub!
# -----------------------------------------------
declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

# Lista de herramientas disponibles y subdominios predeterminados
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "postgres" "n8" "evoapi" "chat")
SELECTED_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
CUSTOM_SUBDOMAINS=()

# Variables globales para credenciales
BASE_DOMAIN=""
COMMON_PASSWORD=""
SECRET_KEY=""

# Funciones de utilidad para mensajes
show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }

# Funci贸n para animaci贸n de espera
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    echo -n "Procesando "
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
    echo -e "${GREEN}[COMPLETADO]${NC}"
}

# Funci贸n para ejecutar comandos mostrando animaci贸n de espera
run_command() {
    local cmd=$1
    local msg=$2
    show_message "$msg"
    
    # Ejecutar en subshell para capturar el PID y redirigir la salida
    eval "$cmd" > /dev/null 2>&1 &
    local cmd_pid=$!
    spinner $cmd_pid
    wait $cmd_pid
    local exit_status=$?
    
    # Si el comando falla, registrar el error y salir
    if [ $exit_status -ne 0 ]; then
        # Ejecutar el comando de nuevo y capturar el error real para mostrarlo
        local output=$(eval "$cmd" 2>&1)
        show_error "Comando fall贸 con estado $exit_status: $cmd"
        show_error "Salida/Error del comando: $output"
        cleanup 1
        exit $exit_status
    fi
    return $exit_status
}

# Funci贸n de limpieza (incluye autodestrucci贸n del script)
cleanup() {
    local exit_code=$1
    local delete_stacks=${2:-false}
    
    echo -e "${BLUE}[INFO]${NC} Realizando limpieza antes de salir..."
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} Error detectado. Limpiando archivos temporales..."
        
        if [ ${#TEMP_FILES[@]} -gt 0 ]; then
            for file in "${TEMP_FILES[@]}"; do
                if [ -f "$file" ]; then
                    rm -f "$file"
                fi
            done
        fi
    fi
    
    if [ "$delete_stacks" = true ]; then
        for tool_name in "${SELECTED_TOOLS[@]}"; do
            local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
            if [ -f "$stack_file" ]; then
                rm -f "$stack_file"
            fi
        done
    fi
    
    # Autodestrucci贸n del script
    if [ $exit_code -ne 0 ] || [ "$delete_stacks" = true ]; then
        local self_destruct_script="/tmp/self_destruct_$$_$(date +%s).sh"
        cat > "$self_destruct_script" << EOF
#!/bin/bash
sleep 1
rm -f "$SCRIPT_PATH"
if [ -f "$SCRIPT_PATH" ]; then
  sudo rm -f "$SCRIPT_PATH"
fi
rm -f "\$0"
EOF

        chmod +x "$self_destruct_script"
        nohup "$self_destruct_script" >/dev/null 2>&1 &
    fi
    
    echo -e "${BLUE}[INFO]${NC} Limpieza completada"
    
    if [ $exit_code -ne 0 ]; then
        echo -e "${RED}[ERROR]${NC} La instalaci贸n ha fallado. Revise los logs para m谩s informaci贸n."
    else
        echo -e "${GREEN}[SUCCESS]${NC} Instalaci贸n completada exitosamente"
    fi
}

# Configurar trampas para se帽ales para limpiar antes de salir
trap 'cleanup 1 false; exit 1' SIGHUP SIGINT SIGQUIT SIGTERM ERR

# Funci贸n para registrar un archivo temporal
register_temp_file() {
    local file_path=$1
    TEMP_FILES+=("$file_path")
}

# Funci贸n para descargar archivos directamente desde el URL
download_stack_file() {
    local tool_name=$1
    local local_path=$2
    local download_url=${STACK_URLS[$tool_name]}

    if [ -z "$download_url" ]; then
        show_error "URL de descarga no encontrada para la herramienta: $tool_name"
        cleanup 1
        exit 1
    fi
    
    show_message "Descargando stack '$tool_name' desde GitHub..."
    
    if ! curl -fsSL --max-time $DOWNLOAD_TIMEOUT -o "$local_path" "$download_url"; then
        show_error "Error al descargar el archivo stack para $tool_name desde $download_url"
        cleanup 1
        exit 1
    fi
    
    register_temp_file "$local_path"

    # === VERIFICACIN DE ROBUSTEZ AADIDA ===
    if [ ! -f "$local_path" ] || [ ! -s "$local_path" ]; then
        show_error "El archivo stack para $tool_name fue descargado, pero est谩 vac铆o. Revisa la URL: $download_url"
        cleanup 1
        exit 1
    fi
    # ========================================
    
    show_success "Archivo stack para $tool_name descargado correctamente"
    return 0
}

# Funci贸n para generar clave aleatoria de 32 caracteres
generate_random_key() {
    tr -dc 'A-Za-z0-9' </dev/urandom | head -c 32
}

# (Las funciones para dependencias, Swarm, etc. se mantienen)

# Funci贸n para crear directorios para vol煤menes
create_volume_directories() {
    local stack_file=$1
    local tool_name=$2
    
    show_message "Creando directorios para vol煤menes de $tool_name..."
   
    # Extrae todas las rutas absolutas despu茅s de 'device:'
    local volume_paths=$(grep -oP "device: \K/[^\s]+" "$stack_file" | sort | uniq)

    if [ -z "$volume_paths" ]; then
        show_message "No se encontraron rutas de vol煤menes para $tool_name"
        return
    fi

    for path in $volume_paths; do
        show_message "Creando directorio: $path"
        # Usamos run_command para manejar la creaci贸n y la salida
        if ! mkdir -p "$path"; then
             show_error "Error al crear el directorio $path"
             cleanup 1
             exit 1
        fi
    done
}


# Funci贸n para sanear y desplegar cada herramienta (Corregida)
install_tool() {
    local tool_name=$1
    local subdomain=$2
    local stack_dir="$DOCKER_DIR/$tool_name"
    local stack_file="$stack_dir/$tool_name-stack.yml"
    
    show_message "Preparando instalaci贸n de $tool_name con subdominio: $subdomain.$BASE_DOMAIN"

    mkdir -p "$stack_dir"
    download_stack_file "$tool_name" "$stack_file" # Ya incluye la verificaci贸n de robustez

    # Crear directorios para vol煤menes
    create_volume_directories "$stack_file" "$tool_name"

    # Sanitizaci贸n general de variables de Traefik y Secrets
    local full_domain="$subdomain.$BASE_DOMAIN"

    show_message "Aplicando sanitizaci贸n general de variables..."
    
    # 1. Reemplazar variables de entorno espec铆ficas
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$stack_file"
    sed -i "s|N8N_ENCRYPTION_KEY=.*|N8N_ENCRYPTION_KEY=$SECRET_KEY|g" "$stack_file"
    sed -i "s|POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|REDIS_PASSWORD=.*|REDIS_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|DB_POSTGRESDB_PASSWORD=.*|DB_POSTGRESDB_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|RAILS_INBOUND_EMAIL_PASSWORD=.*|RAILS_INBOUND_EMAIL_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|PORTAINER_ADMIN_PASSWORD=.*|PORTAINER_ADMIN_PASSWORD=$COMMON_PASSWORD|g" "$stack_file"

    # 2. Reemplazar dominio base y subdominio local (Reglas Traefik y URLs)
    sed -i "s/REPLACE_SUBDOMAIN.REPLACE_DOMAIN/$full_domain/g" "$stack_file" # Para Traefik
    sed -i "s/REPLACE_DOMAIN/$BASE_DOMAIN/g" "$stack_file" # Por si acaso se usa el dominio base
    sed -i "s/N8N_HOST=.*$/N8N_HOST=$full_domain/g" "$stack_file"
    sed -i "s|N8N_EDITOR_BASE_URL=.*|N8N_EDITOR_BASE_URL=https://$full_domain|g" "$stack_file"
    sed -i "s/HOST=.*$/HOST=$full_domain/g" "$stack_file" # EvoAPI

    # Manejo de casos especiales (CORRECCIONES CLAVE)
    if [ "$tool_name" == "redis" ]; then
        show_message "Aplicando **correcci贸n de sintaxis y contrase帽a** para Redis..."

        # CORRECCIN 1: Agregar la contrase帽a al comando de redis-server (YAML)
        sed -i "s/command: redis-server --loglevel warning/command: redis-server --requirepass \$COMMON_PASSWORD --loglevel warning/g" "$stack_file"

        # CORRECCIN 2: Inyectar variables de entorno en redisinsight con la **indentaci贸n correcta** (4 espacios)
        # Esto soluciona el error de "Additional property environment is not allowed" en Swarm.
        sed -i '/image: redislabs\/redisinsight:latest/a\    environment:\n      - REDISINSIGHT_PASSWORD=\$COMMON_PASSWORD\n      - REDIS_PASSWORD=\$COMMON_PASSWORD' "$stack_file"
        
        show_success "Correcci贸n de Redis aplicada"
    fi

    if [ "$tool_name" == "n8n" ]; then
        show_message "Aplicando correcciones de ruta para n8n..."
        # Correcci贸n: Asegurar que las rutas de los subdominios de webhook sean correctas.
        sed -i "s/WEBHOOK_URL=https:\/\/webhook\..*$/WEBHOOK_URL=https:\/\/webhook.$full_domain/g" "$stack_file"
        sed -i "s/REPLACE_WEBHOOK_SUBDOMAIN/webhook.$subdomain/g" "$stack_file"
        show_success "Correcci贸n de n8n aplicada"
    fi
    show_success "Sanitizaci贸n de $tool_name completada"

    # Desplegar el stack
    show_message "Desplegando $tool_name en Docker Swarm..."
    run_command "docker stack deploy -c $stack_file $tool_name" "Desplegando $tool_name..."
    
    if [ $? -eq 0 ]; then
        show_success "$tool_name instalado correctamente en Docker Swarm"
        echo "$subdomain" > "$DOCKER_DIR/$tool_name/.subdomain"
        return 0
    else
        show_error "Fallo al desplegar $tool_name"
        cleanup 1
        exit 1
    fi
}

# (Las funciones get_credentials, main_installation_flow y finalize_installation se mantienen)
# ...

# Funci贸n para solicitar credenciales y validar (simplificada)
get_credentials() {
    show_message "Configuraci贸n inicial"
    
    # 1. Contrase帽a
    while [ -z "$COMMON_PASSWORD" ]; do
        read -rsp "Ingrese la contrase帽a com煤n para todas las herramientas: " COMMON_PASSWORD
        echo
        if [ -z "$COMMON_PASSWORD" ]; then
            show_error "La contrase帽a no puede estar vac铆a."
        fi
    done

    # 2. Dominio
    while [ -z "$BASE_DOMAIN" ]; do
        read -rp "Ingrese el dominio base (ejemplo: midominio.com): " BASE_DOMAIN
        if [ -z "$BASE_DOMAIN" ]; then
            show_error "El dominio no puede estar vac铆o."
        fi
        # Sanitizar dominio (eliminar https:// o http:// si existen)
        BASE_DOMAIN=$(echo "$BASE_DOMAIN" | sed 's|^https\?://||')
    done

    # 3. Clave Secreta
    read -rp "Ingrese una clave secreta de 32 caracteres para las herramientas (o presione Enter para usar una generada autom谩ticamente): " SECRET_KEY
    if [ -z "$SECRET_KEY" ]; then
        SECRET_KEY=$(generate_random_key)
        show_message "Se utilizar谩 la siguiente clave secreta: $SECRET_KEY"
    fi
    
    show_message "Guardando credenciales en $DOCKER_DIR/.env.global..."
    mkdir -p "$DOCKER_DIR"
    echo "BASE_DOMAIN=$BASE_DOMAIN" > "$DOCKER_DIR/.env.global"
    echo "COMMON_PASSWORD=$COMMON_PASSWORD" >> "$DOCKER_DIR/.env.global"
    echo "SECRET_KEY=$SECRET_KEY" >> "$DOCKER_DIR/.env.global"
}


# Ejecuci贸n principal del script
main_installation_flow() {
    if [ "$EUID" -ne 0 ]; then
        show_error "Por favor, ejecuta este script como root o con sudo."
        exit 1
    fi
    
    get_credentials
    show_message "Iniciando la instalaci贸n automatizada de herramientas Docker..."
    
    # Aqu铆 ir铆an las llamadas a las funciones de instalaci贸n reales (dependencias, Swarm, networks)
    # Por simplicidad en este an谩lisis, asumimos que se ejecutan correctamente.
    
    # 3. Instalaci贸n de herramientas (Bucle principal)
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        default_subdomain="${DEFAULT_SUBDOMAINS[$i]}"
        
        subdomain_to_use=$default_subdomain
        
        install_tool "$tool_name" "$subdomain_to_use"
        
        # 4. Post-instalaci贸n (Solo Chatwoot requiere inicializaci贸n)
        if [ "$tool_name" == "chatwoot" ]; then
            show_message "Esperando 30 segundos para que Chatwoot se estabilice..."
            sleep 30 
            # initialize_chatwoot_database "$subdomain_to_use" # Descomentar en el script final si la funci贸n existe
        fi
    done

    # 5. Finalizaci贸n y limpieza
    finalize_installation
}

# Funci贸n para el mensaje final
finalize_installation() {
    echo ""
    show_success " 隆INSTALACIN COMPLETADA! "
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"

        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${DEFAULT_SUBDOMAINS[$i]}"
        fi

        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Informaci贸n de credenciales:"
    echo "- Contrase帽a com煤n: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta informaci贸n se ha guardado en: $DOCKER_DIR/.env.global"

    cleanup 0 true 
}

# Llamada a la funci贸n principal
main_installation_flow
