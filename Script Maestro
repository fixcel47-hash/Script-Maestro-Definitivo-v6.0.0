#!/usr/bin/env bash
# =================================================================================
# INSTALADOR UNIFICADO DOCKER SWARM (v6.0.0 - FINAL DEFINITIVO)
# Autor: Adaptado y corregido por Gemini AI (Integración de Khunter Fix + INYECCIÓN DE VARIABLES)
# Objetivo: Instalación robusta de stack Docker Swarm, corrigiendo fallos de autenticación (Redis, EvoAPI P1000).
# =================================================================================

SCRIPT_VERSION="6.0.0-FINAL"

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables de entorno
DOCKER_DIR="/home/docker"
TEMP_FILES=()
DOWNLOAD_TIMEOUT=30

# -----------------------------------------------
# 1. Configuración de Herramientas y URLs (Usando tus URLs de GitHub)
# -----------------------------------------------
AVAILABLE_TOOLS=("traefik" "portainer" "redis" "postgres" "n8n" "evoapi" "chatwoot")
DEFAULT_SUBDOMAINS=("proxy" "admin" "redis" "db" "n8" "api" "chat")

declare -gA STACK_URLS=(
    [chatwoot]="https://github.com/user-attachments/files/22956465/chatwoot-stack.yml"
    [chatwoot-init]="https://github.com/user-attachments/files/22988366/chatwoot-init-stack.yml" 
    [evoapi]="https://github.com/user-attachments/files/22956481/evoapi-stack.yml"
    [n8n]="https://github.com/user-attachments/files/22956487/n8n-stack.yml"
    [portainer]="https://github.com/user-attachments/files/22956492/portainer-stack.yml"
    [postgres]="https://github.com/user-attachments/files/22956495/postgres-stack.yml"
    [redis]="https://github.com/user-attachments/files/22956503/redis-stack.yml"
    [traefik]="https://github.com/user-attachments/files/22956506/traefik-stack.yml"
)

# -----------------------------------------------
# 2. Funciones de Utilidad y Flujo
# -----------------------------------------------

show_message() { echo -e "${BLUE}[INFO]${NC} $1"; }
show_error() { echo -e "${RED}[ERROR]${NC} $1"; }
show_success() { echo -e "${GREEN}[SUCCESS]${NC} $1"; }
show_warning() { echo -e "${YELLOW}[ADVERTENCIA]${NC} $1"; }

read_input() {
    local prompt="$1"
    local default_val="$2"
    local result_var="$3"
    
    if [ -z "${!result_var}" ]; then
        echo -n -e "${BLUE}[PREGUNTA]${NC} $prompt (Predeterminado: $default_val): "
        read user_input
        if [ -z "$user_input" ]; then
            eval $result_var=\"$default_val\"
        else
            eval $result_var=\"$user_input\"
        fi
    fi
}

cleanup() {
    local exit_code=$1
    echo ""
    show_message "Realizando limpieza antes de salir..."
    
    if [ ${#TEMP_FILES[@]} -gt 0 ]; then
        rm -f "${TEMP_FILES[@]}" 2>/dev/null
    fi

    if [ $exit_code -ne 0 ] && [ -f "$DOCKER_DIR/.env.global" ]; then
        show_warning "El archivo $DOCKER_DIR/.env.global se mantiene para depuración."
    fi

    show_message "Limpieza de archivos temporales completada."
    
    if [ $exit_code -ne 0 ]; then
        show_error "Instalación fallida"
    else
        show_success "Instalación completada exitosamente"
    fi

    exit $exit_code
}

trap 'cleanup 1' ERR INT TERM

validate_prerequisites() {
    if ! command -v docker &> /dev/null; then
        show_error "Docker no está instalado. Por favor, instala Docker y Docker Compose."
        cleanup 1
    fi

    if ! docker info 2>/dev/null | grep -q "Swarm: active"; then
        show_message "Docker Swarm no está activo. Inicializando..."
        if ! docker swarm init &> /dev/null; then
            show_error "No se pudo inicializar Docker Swarm."
            cleanup 1
        fi
        show_success "Docker Swarm inicializado."
    fi
    show_success "Requisitos de Docker validados."
}

configure_variables() {
    show_message "Configuración de variables de entorno y credenciales."
    
    read_input "Ingrese el dominio base (ej. midominio.com)" "" BASE_DOMAIN
    read_input "Ingrese la contraseña común para todos los servicios" "$(openssl rand -base64 12 | tr -d '=+/' | cut -c1-12)" COMMON_PASSWORD
    read_input "Ingrese la clave secreta única" "$(openssl rand -base64 24 | tr -d '=+/' | cut -c1-24)" SECRET_KEY

    # Exportar variables de forma global
    export BASE_DOMAIN COMMON_PASSWORD SECRET_KEY DOCKER_DIR

    mkdir -p "$DOCKER_DIR"
    {
        echo "BASE_DOMAIN=$BASE_DOMAIN"
        echo "COMMON_PASSWORD=$COMMON_PASSWORD"
        echo "SECRET_KEY=$SECRET_KEY"
    } > "$DOCKER_DIR/.env.global"
    show_success "Variables globales guardadas y EXPORTADAS."
    
    show_message "Seleccione las herramientas a instalar (separadas por espacio):"
    echo "Opciones disponibles: ${AVAILABLE_TOOLS[@]}"
    
    read -p "Su selección (ej. traefik portainer chatwoot): " USER_SELECTION
    
    local -a selected_temp
    for tool in $USER_SELECTION; do
        if [[ " ${AVAILABLE_TOOLS[@]} " =~ " ${tool} " ]]; then
            selected_temp+=("$tool")
        else
            show_warning "Herramienta '$tool' no reconocida y será ignorada."
        fi
    done

    if [ ${#selected_temp[@]} -eq 0 ]; then
        show_error "No se seleccionó ninguna herramienta válida. Abortando. Asegúrate de incluir 'traefik'."
        cleanup 1
    fi
    
    SELECTED_TOOLS=("${selected_temp[@]}")
    show_message "Herramientas seleccionadas: ${SELECTED_TOOLS[@]}"

    declare -gA CUSTOM_SUBDOMAINS
    for i in "${!SELECTED_TOOLS[@]}"; do
        tool_name="${SELECTED_TOOLS[$i]}"
        
        local default_subdomain_found=""
        for j in "${!AVAILABLE_TOOLS[@]}"; do
            if [ "${AVAILABLE_TOOLS[$j]}" = "$tool_name" ]; then
                default_subdomain_found="${DEFAULT_SUBDOMAINS[$j]}"
                break
            fi
        done
        
        read_input "Ingrese el subdominio para $tool_name" "$default_subdomain_found" "CUSTOM_SUBDOMAINS[$tool_name]"
        
        echo "${CUSTOM_SUBDOMAINS[$tool_name]}" > "$DOCKER_DIR/$tool_name/.subdomain"
        export ${tool_name^^}_SUBDOMAIN="${CUSTOM_SUBDOMAINS[$tool_name]}"
    done
}

create_networks_and_dirs() {
    show_message "Creando directorios y redes Docker Swarm..."
    
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        mkdir -p "$DOCKER_DIR/$tool_name"
    done
    
    for network in "traefik-public" "docker-flow"; do
        if ! docker network ls | grep -q "$network"; then
            show_message "Creando red '$network'..."
            docker network create -d overlay --attachable "$network" >/dev/null
            if [ $? -ne 0 ]; then
                show_error "No se pudo crear la red $network."
                cleanup 1
            fi
        fi
    done
    show_success "Directorios y redes creados."
}

# -----------------------------------------------
# 3. Funciones de Instalación (CON INYECCIÓN SED CORREGIDA)
# -----------------------------------------------

# Función que inyecta variables y corrige fallos en el YAML antes de desplegar
process_yaml_and_deploy() {
    local tool_name="$1"
    local stack_file="$2"

    show_message "Aplicando configuración y credenciales a $tool_name-stack.yml..."

    # a) Reemplazo global de variables (CRÍTICO)
    sed -i "s|REPLACE_DOMAIN|$BASE_DOMAIN|g" "$stack_file"
    sed -i "s|REPLACE_SUBDOMAIN|${CUSTOM_SUBDOMAINS[$tool_name]}|g" "$stack_file"
    sed -i "s|REPLACE_COMMON_PASSWORD|$COMMON_PASSWORD|g" "$stack_file"
    sed -i "s|REPLACE_SECRET_KEY|$SECRET_KEY|g" "$stack_file"

    # b) Correcciones específicas de servicios
    if [ "$tool_name" == "redis" ]; then
        show_message "Aplicando corrección de comando y credenciales para Redis..."
        # 1. Agrega la contraseña al comando de ejecución (Soluciona el error 'wrong number of arguments')
        sed -i "s/command: redis-server --loglevel warning/command: redis-server --requirepass $COMMON_PASSWORD --loglevel warning/g" "$stack_file"
        # 2. Asegura la definición de variables en RedisInsight
        # Se asume que el YML tiene un placeholder o un espacio para insertar esto. Si el YML no tiene un environment: en RedisInsight, esta línea puede fallar.
        if ! grep -q "REDISINSIGHT_PASSWORD" "$stack_file"; then
             sed -i '/image: redislabs\/redisinsight:latest/a\    environment:\n      - REDISINSIGHT_PASSWORD='$COMMON_PASSWORD'\n      - REDIS_PASSWORD='$COMMON_PASSWORD'' "$stack_file"
        fi
    fi

    if [ "$tool_name" == "evoapi" ]; then
        show_message "Aplicando corrección de credenciales para EvoAPI (Error P1000)..."
        # 1. Inyecta la contraseña directamente en la DATABASE_URL
        sed -i "s/postgres:\${COMMON_PASSWORD}/postgres:$COMMON_PASSWORD/g" "$stack_file"
        # 2. Asegura que la DB de EvoAPI tenga la contraseña
        sed -i "s/\(POSTGRES_PASSWORD=\).*/\1$COMMON_PASSWORD/g" "$stack_file"
    fi

    show_success "Configuración aplicada."
    
    # 4. Despliegue del Stack
    docker stack deploy -c "$stack_file" "$tool_name"
    
    if [ $? -ne 0 ]; then
        show_error "Error al desplegar el stack $tool_name."
        return 1
    fi
    show_success "Stack $tool_name desplegado."
    
    # 5. Post-instalación (esperas para estabilidad)
    if [ "$tool_name" == "redis" ] || [ "$tool_name" == "postgres" ]; then
        show_message "Esperando a que $tool_name se estabilice (15 segundos)..."
        sleep 15
    fi

    return 0
}

# Inicialización robusta de Chatwoot (Flujo de Khunter Fix)
initialize_chatwoot_database() {
    local final_stack_name="chatwoot"
    local init_stack_name="chatwoot-init"
    local postgres_volume_name="${init_stack_name}_chatwoot-postgres-data" 
    
    show_message "Iniciando proceso de inicialización de Chatwoot (Stack Temporal: $init_stack_name)..."
    
    # 1. Descargar stack TEMPORAL de inicialización
    local temp_file="$DOCKER_DIR/$final_stack_name/${init_stack_name}.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot-init]}" -o "$temp_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el stack de inicialización de Chatwoot. Abortando."
        return 1
    fi
    TEMP_FILES+=("$temp_file")

    # INYECCIÓN DE VARIABLES en el stack de inicialización (CRÍTICO)
    show_message "Inyectando credenciales en el stack de inicialización..."
    sed -i "s|REPLACE_COMMON_PASSWORD|$COMMON_PASSWORD|g" "$temp_file"
    
    show_message "Desplegando stack temporal '$init_stack_name'..."
    docker stack deploy -c "$temp_file" "$init_stack_name"
    
    show_message "Esperando 45 segundos a que la base de datos de inicialización esté lista..."
    sleep 45

    # 2. Ejecutar la migración (Lógica de contenedor robusta)
    local init_container_id=$(docker service ps -q "${init_stack_name}_chatwoot-setup" --filter "desired-state=running" | head -n 1)
    if [ -z "$init_container_id" ]; then
        init_container_id=$(docker service ps -q "${init_stack_name}_db-init" --filter "desired-state=running" | head -n 1)
        if [ -z "$init_container_id" ]; then
             show_error "Contenedor de setup no encontrado. Abortando inicialización."
             return 1
        fi
    fi
    
    show_message "Ejecutando la inicialización (db:setup) en $init_container_id..."
    
    if ! docker container exec -t "$init_container_id" /bin/bash -c "RAILS_ENV=production bundle exec rails db:setup"; then
        show_warning "El comando db:setup finalizó con un código de error. Continuando con la limpieza..."
    fi

    # 3. Limpiar el stack TEMPORAL
    show_message "Eliminando el stack temporal '$init_stack_name'..."
    docker stack rm "$init_stack_name"
    sleep 5 # Pequeña espera para liberar el volumen
    show_success "Stack temporal '$init_stack_name' eliminado."

    # 4. Eliminar el volumen de datos de la inicialización de forma robusta
    show_message "Intentando eliminar el volumen temporal '$postgres_volume_name'..."
    local attempts=0
    while [ $attempts -lt 5 ]; do
        if docker volume rm "$postgres_volume_name" 2>/dev/null; then
            show_success "Volumen temporal '$postgres_volume_name' eliminado."
            break
        else
            show_message "Intento $((attempts+1)): Volumen aún en uso. Esperando 5 segundos..."
            sleep 5
            attempts=$((attempts+1))
        fi
    done
    if [ $attempts -eq 5 ]; then
        show_warning "No se pudo eliminar el volumen '$postgres_volume_name'. Podría requerir eliminación manual."
    fi

    show_success "Base de datos de Chatwoot inicializada."

    # 5. Desplegar el stack FINAL de Chatwoot
    local final_deploy_file="$DOCKER_DIR/$final_stack_name/${final_stack_name}-deploy.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[chatwoot]}" -o "$final_deploy_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el stack final de Chatwoot. Abortando."
        return 1
    fi
    TEMP_FILES+=("$final_deploy_file")
    
    show_message "Desplegando chatwoot (Stack Final: $final_stack_name)..."
    
    # Procesa el YAML final de Chatwoot antes de desplegar
    process_yaml_and_deploy "chatwoot" "$final_deploy_file"

    return 0
}

# Función para el resto de stacks
deploy_stack() {
    local tool_name="$1"

    show_message "Iniciando instalación de $tool_name..."
    
    # 1. Descargar Stack File
    local stack_file="$DOCKER_DIR/$tool_name/$tool_name-stack.yml"
    curl -fsSL --connect-timeout $DOWNLOAD_TIMEOUT "${STACK_URLS[$tool_name]}" -o "$stack_file"
    if [ $? -ne 0 ]; then
        show_error "No se pudo descargar el archivo stack para $tool_name. Revisar URL: ${STACK_URLS[$tool_name]}"
        return 1
    fi
    TEMP_FILES+=("$stack_file")

    # 2. PROCESAMIENTO CRÍTICO Y DESPLIEGUE
    process_yaml_and_deploy "$tool_name" "$stack_file"

    return 0
}

# -----------------------------------------------
# 4. Flujo Principal
# -----------------------------------------------

main_installation() {
    validate_prerequisites
    configure_variables
    create_networks_and_dirs

    # Desplegar Traefik (debe ser el primero)
    if [[ " ${SELECTED_TOOLS[@]} " =~ " traefik " ]]; then
        deploy_stack "traefik" || cleanup 1
        
        show_message "Esperando 30 segundos para el provisionamiento inicial de Traefik y Let's Encrypt..."
        sleep 30 
    else
        show_error "El stack Traefik es obligatorio. Por favor, inclúyelo en la selección."
        cleanup 1
    fi

    # Desplegar el resto de herramientas
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        if [ "$tool_name" == "traefik" ]; then
            continue
        fi

        if [ "$tool_name" == "chatwoot" ]; then
            initialize_chatwoot_database || cleanup 1
        else
            deploy_stack "$tool_name" || cleanup 1
        fi
    done

    # 5. Mensaje final
    finalize_installation
}

finalize_installation() {
    echo ""
    show_success "🎉 ¡INSTALACIÓN COMPLETADA! 🎉"
    echo ""
    show_message "Verifique que todos los servicios estén en estado '1/1' con 'docker service ls'."
    echo ""
    echo "Accede a tus servicios en los siguientes URLs:"
    
    for tool_name in "${SELECTED_TOOLS[@]}"; do
        subdomain_file="$DOCKER_DIR/$tool_name/.subdomain"
        
        if [ -f "$subdomain_file" ]; then
            subdomain=$(cat "$subdomain_file")
        else
            subdomain="${CUSTOM_SUBDOMAINS[$tool_name]}"
        fi

        TOOL_NAME_CAPITALIZED=$(echo "$tool_name" | awk '{print toupper(substr($0,1,1))tolower(substr($0,2))}')
        
        echo "- ${TOOL_NAME_CAPITALIZED}: https://$subdomain.$BASE_DOMAIN"
    done
    
    echo ""
    echo "Información de credenciales:"
    echo "- Contraseña común: $COMMON_PASSWORD"
    echo "- Clave secreta: $SECRET_KEY"
    echo ""
    echo "Esta información se ha guardado en: $DOCKER_DIR/.env.global"
    
    cleanup 0
}

# Ejecutar el script
main_installation
